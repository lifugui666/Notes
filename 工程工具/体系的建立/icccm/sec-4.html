<HTML>
<HEAD>
<TITLE>ICCCM - Client to Window Manager Communication</TITLE>
</HEAD>

<BODY>
<H1><A NAME="s-4">4.</A> Client to Window Manager Communication</H1>
To permit window managers to perform their role of mediating the competing
demands for resources such as screen space,
the clients being managed must adhere to certain conventions
and must expect the window managers to do likewise.
These conventions are covered here from the client's point of view.
<P>
In general,
these conventions are somewhat complex
and will undoubtedly change as new window management paradigms are developed.
Thus, there is a strong bias toward defining only those conventions
that are essential and that apply generally to all window management paradigms.
Clients designed to run with a particular window manager can easily
define private protocols to add to these conventions,
but they must be aware that their users may decide to run some other
window manager no matter how much the designers of the private protocol
are convinced that they have seen the &quot;one true light&quot; of user interfaces.
<P>
It is a principle of these conventions that a general client should
neither know nor care which window manager is running or, indeed, 
if one is running at all.
The conventions do not support all client functions 
without a window manager running;
for example, the concept of Iconic 
is not directly supported by clients.
If no window manager is running,
the concept of Iconic does not apply.
A goal of the conventions is to make it possible to kill and
restart window managers without loss of functionality.
<P>
Each window manager will implement a particular window management policy;
the choice of an appropriate window management policy
for the user's circumstances is not one for an individual client to
make but will be made by the user or the user's system administrator.
This does not exclude the possibility of writing clients that
use a private protocol to restrict themselves to operating only
under a specific window manager.
Rather, 
it merely ensures that no claim of general utility is made for such programs.
<P>
For example,
the claim is often made: 
&quot;The client I'm writing is important, and it needs to be on top.&quot;
Perhaps it is important when it is being run in earnest,
and it should then be run under the control of a window manager 
that recognizes &quot;important&quot; windows through some private protocol 
and ensures that they are on top.
However, imagine, for example, that the &quot;important&quot; client is being debugged.
Then,  ensuring that it is always on top is no longer 
the appropriate window management policy,
and it should be run under a window manager that allows other windows 
(for example, the debugger) to appear on top.

<H2><A NAME="s-4.1">4.1.</A> Client's Actions</H2>
In general, 
the object of the X Version 11 design is that clients should,
as far as possible, do exactly what they would do in the absence 
of a window manager, except for the following:
<UL>
<LI> Hinting to the window manager about the resources they would like
to obtain
<LI> Cooperating with the window manager by accepting the resources they
are allocated even if they are not those requested
<LI> Being prepared for resource allocations to change at any time

</UL>
<H3><A NAME="s-4.1.1">4.1.1.</A> Creating a Top-Level Window</H3>
A client's <I>top-level window</I> is a window whose override-redirect
attribute is
<B>False .</B>
It must either be a child of a root window, or it must have been a child of
a root window immediately prior to having been reparented by the window
manager.  If the client reparents the window away from the root, the window
is no longer a top-level window; but it can become a top-level window again
if the client reparents it back to the root.
<P>
A client usually would expect to create its top-level windows
as children of one or more of the root windows by using some
boilerplate like the following:
<P>
<PRE><CODE>
win = XCreateSimpleWindow(dpy, DefaultRootWindow(dpy), xsh.x, xsh.y,
	xsh.width, xsh.height, bw, bd, bg);
</CODE></PRE>
<P>
If a particular one of the root windows was required, however,
it could use something like the following:
<P>
<PRE><CODE>
win = XCreateSimpleWindow(dpy, DefaultRootWindow(dpy), xsh.x, xsh.y,
	xsh.width, xsh.height, bw, bd, bg);
</CODE></PRE>
<P>
Ideally,
it should be possible to override the choice of a root window 
and allow clients (including window managers) to treat a nonroot window 
as a pseudo-root.
This would allow, for example, the testing of window managers and the
use of application-specific window managers to control the subwindows
owned by the members of a related suite of clients.
Doing so properly requires an extension,
the design of which is under study.
<P>
From the client's point of view,
the window manager will regard its top-level window as being in 
one of three states:
<UL>
<LI> Normal
<LI> Iconic
<LI> Withdrawn
</UL>
Newly created windows start in the Withdrawn state.
Transitions between states happen when the top-level window is mapped
and unmapped and when the window manager receives certain messages.
For further details, see sections <A HREF="sec-4.html#s-4.1.2.4">4.1.2.4</A> and <A HREF="sec-4.html#s-4.1.4">4.1.4</A>.

<H3><A NAME="s-4.1.2">4.1.2.</A> Client Properties</H3>
Once the client has one or more top-level windows, 
it should place properties on those windows to inform the window manager 
of the behavior that the client desires.
Window managers will assume values they find convenient 
for any of these properties that are not supplied;
clients that depend on particular values must explicitly supply them.
The window manager will not change properties written by the client.
<P>
The window manager will examine the contents of these
properties when the window makes the transition from the Withdrawn state
and will monitor some properties for changes while the window is 
in the Iconic or Normal state.
When the client changes one of these properties, 
it must use 
<B>Replace</B>
mode to overwrite the entire property with new data;
the window manager will retain no memory of the old value of the property.
All fields of the property must be set to suitable values in a single 
<B>Replace</B>
mode 
<B>ChangeProperty</B>
request.
This ensures that the full contents of the property will be
available to a new window manager if the existing one crashes,
if it is shut down and restarted,
or if the session needs to be shut down and restarted by the session manager.
<P ALIGN=center> Convention
<BLOCKQUOTE>
<P>Clients writing or rewriting window manager properties must
ensure that the entire content of each property remains valid
at all times.
</BLOCKQUOTE>
<P>
Some of these properties may contain the IDs of resources, such as
windows or pixmaps.  Clients should ensure that these resources exist
for at least as long as the window on which the property resides.
<P>
If these properties are longer than expected,
clients should ignore the remainder of the property.
Extending these properties is reserved to the X Consortium;
private extensions to them are forbidden.
Private additional communication between clients and window managers 
should take place using separate properties.
The only exception to this rule is the WM_PROTOCOLS property, which may be
of arbitrary length and which may contain atoms representing private
protocols; see <A HREF="sec-4.html#s-4.1.2.7">section 4.1.2.7</A>.
<P>
The next sections describe each of the properties the clients
need to set, in turn.
They are summarized in the table in <A HREF="sec-4.html#s-4.4">section 4.4</A>.

<A NAME="WM_NAME"></A>
<H4><A NAME="s-4.1.2.1">4.1.2.1.</A> WM_NAME Property</H4>
The WM_NAME property is an uninterpreted string 
that the client wants the window manager to display
in association with the window (for example, in a window headline bar).
<P>
The encoding used for this string 
(and all other uninterpreted string properties) 
is implied by the type of the property.
The type atoms to be used for this purpose are described in <A HREF="sec-2.html#s-2.7.1">section 2.7.1</A>.
<P>
Window managers are expected to make an effort to display this information.
Simply ignoring WM_NAME is not acceptable behavior.
Clients can assume that at least the first part of this string
is visible to the user and that if the information is not visible to the user,
it is because the user has taken an explicit action to make it invisible.
<P>
On the other hand,
there is no guarantee that the user can see the WM_NAME string 
even if the window manager supports window headlines.
The user may have placed the headline off-screen
or have covered it by other windows.
WM_NAME should not be used for application-critical information 
or to announce asynchronous changes of an application's state 
that require timely user response.
The expected uses are to permit the user to identify one of a
number of instances of the same client
and to provide the user with noncritical state information.
<P>
Even window managers that support headline bars will place some limit 
on the length of the WM_NAME string that can be visible;
brevity here will pay dividends.

<A NAME="WM_ICON_NAME"></A>
<H4><A NAME="s-4.1.2.2">4.1.2.2.</A> WM_ICON_NAME Property</H4>
The WM_ICON_NAME property is an uninterpreted string 
that the client wants to be displayed in association with the window 
when it is iconified (for example, in an icon label).
In other respects, 
including the type, it is similar to WM_NAME.
For obvious geometric reasons,
fewer characters will normally be visible in WM_ICON_NAME than WM_NAME.
<P>
Clients should not attempt to display this string in their icon pixmaps
or windows; rather, they should rely on the window manager to do so.

<A NAME="WM_NORMAL_HINTS"></A>
<H4><A NAME="s-4.1.2.3">4.1.2.3.</A> WM_NORMAL_HINTS Property</H4>
The type of the WM_NORMAL_HINTS property is WM_SIZE_HINTS.
Its contents are as follows:
<TABLE>
<TR><TH COLSPAN=3><HR>
<TR><TH ALIGN=left>Field	<TH ALIGN=left>Type	<TH ALIGN=left>Comments
<TR><TH COLSPAN=3><HR>
<TR><TD>flags	<TD>CARD32	<TD>(see the next table)
<TR><TD>pad	<TD>4*CARD32	<TD>For backwards compatibility
<TR><TD>max_width	<TD>INT32
<TR><TD>max_height	<TD>INT32
<TR><TD>width_inc	<TD>INT32
<TR><TD>height_inc	<TD>INT32
<TR><TD>max_aspect	<TD>(INT32,INT32)
<TR><TD>base_width	<TD>INT32	<TD>If missing, assume min_width
<TR><TD>base_height	<TD>INT32	<TD>If missing, assume min_height
<TR><TD>win_gravity	<TD>If missing, assume <B>NorthWest</B>
<TR><TH COLSPAN=3><HR>
</TABLE>

<P>
The WM_SIZE_HINTS.flags bit definitions are as follows:
<TABLE>
<TR><TH COLSPAN=3><HR>
<TR><TH ALIGN=left>Name	<TH ALIGN=left>Value	<TH ALIGN=left>Field
<TR><TH COLSPAN=3><HR>
<TR><TD><B>USPosition</B>	<TD>1	<TD>User-specified x, y
<TR><TD><B>USSize</B>	<TD>2	<TD>User-specified width, height
<TR><TD><B>PPosition</B>	<TD>4	<TD>Program-specified position
<TR><TD><B>PSize</B>	<TD>8	<TD>Program-specified size
<TR><TD><B>PMinSize</B>	<TD>16	<TD>Program-specified minimum size
<TR><TD><B>PMaxSize</B>	<TD>32	<TD>Program-specified maximum size
<TR><TD><B>PResizeInc</B>	<TD>64	<TD>Program-specified resize increments
<TR><TD><B>PAspect</B>	<TD>128	<TD>Program-specified min and max aspect ratios
<TR><TD><B>PBaseSize</B>	<TD>256	<TD>Program-specified base size
<TR><TD><B>PWinGravity</B>	<TD>512	<TD>Program-specified window gravity
<TR><TH COLSPAN=3><HR>
</TABLE>

<P>
To indicate that the size and position of the window 
(when a transition from the Withdrawn state occurs) was specified by the user, 
the client should set the
<B>USPosition</B>
and
<B>USSize</B>
flags, 
which allow a window manager to know that the user specifically asked where
the window should be placed or how the window should be sized and that
further interaction is superfluous.
To indicate that it was specified by the client without any user involvement,
the client should set 
<B>PPosition</B>
and 
<B>PSize .</B>
<P>
The size specifiers refer to the width and height of the client's
window excluding borders.
<P>
The win_gravity may be any of the values specified for WINGRAVITY in
the core protocol except for
<B>Unmap :</B>
<B>NorthWest </B>
(1), 
<B>North </B>
(2), 
<B>NorthEast </B>
(3), 
<B>West </B>
(4), 
<B>Center</B>
(5),
<B>East</B>
(6), 
<B>SouthWest</B>
(7),
<B>South</B>
(8), and 
<B>SouthEast</B>
(9).  It specifies how and whether the client window wants to be shifted to
make room for the window manager frame.
<P>
If the win_gravity is
<B>Static ,</B>
the window manager frame is positioned
so that the inside border of the client window inside the frame is
in the same position on the screen as it was when the client
requested the transition from Withdrawn state.  Other values of
win_gravity specify a window reference point.  For
<B>NorthWest ,</B>
<B>NorthEast ,</B>
<B>SouthWest ,</B>
and
<B>SouthEast</B>
the reference point is the specified outer corner of the window (on the
outside border edge).  For
<B>North ,</B>
<B>South ,</B>
<B>East ,</B>
and
<B>West</B>
the reference point is the center of the specified outer edge of the window
border.  For
<B>Center</B>
the reference point is the center of the window.  The reference point of the
window manager frame is placed at the location on the screen where the
reference point of the client window was when the client requested the
transition from Withdrawn state.
<P>
The min_width and min_height elements specify the
minimum size that the window can be for the client to be useful.
The max_width and max_height elements specify the maximum size.
The base_width and base_height elements in conjunction with width_inc
and height_inc define an arithmetic progression of preferred window
widths and heights for nonnegative integers <I>i</I> and <I>j</I>:
<P>
<MATH>width = base_width + (i &#215; width_inc)<BR>height = base_height + (j &#215; height_inc)</MATH>
<P>
Window managers are encouraged to use <I>i</I> and <I>j</I> 
instead of width and height in reporting window sizes to users.
If a base size is not provided, 
the minimum size is to be used in its place and vice versa.
<P>
The min_aspect and max_aspect fields are fractions with the numerator first
and the denominator second, and they allow a client to specify the range of
aspect ratios it prefers.  Window managers that honor aspect ratios should
take into account the base size in determining the preferred window size.  If
a base size is provided along with the aspect ratio fields, the base size
should be subtracted from the window size prior to checking that the aspect
ratio falls in range.  If a base size is not provided, nothing should be
subtracted from the window size.  (The minimum size is not to be used in
place of the base size for this purpose.)

<A NAME="WM_HINTS"></A>
<H4><A NAME="s-4.1.2.4">4.1.2.4.</A> WM_HINTS Property</H4>
The WM_HINTS property (whose type is WM_HINTS)
is used to communicate to the window manager.
It conveys the information the window manager needs 
other than the window geometry,
which is available from the window itself;
the constraints on that geometry,
which is available from the WM_NORMAL_HINTS structure;
and various strings,
which need separate properties, such as WM_NAME.
The contents of the properties are as follows:
<TABLE>
<TR><TH COLSPAN=3><HR>
<TR><TH ALIGN=left>Field	<TH ALIGN=left>Type	<TH ALIGN=left>Comments
<TR><TH COLSPAN=3><HR>
<TR><TD>flags	<TD>CARD32	<TD>(see the next table)
<TR><TD>input	<TD>CARD32	<TD>The client's input model
<TR><TD>initial_state	<TD>CARD32	<TD>The state when first mapped
<TR><TD>icon_pixmap	<TD>PIXMAP	<TD>The pixmap for the icon image
<TR><TD>icon_window	<TD>WINDOW	<TD>The window for the icon image
<TR><TD>icon_x	<TD>INT32	<TD>The icon location
<TR><TD>icon_y	<TD>INT32
<TR><TD>icon_mask	<TD>PIXMAP	<TD>The mask for the icon shape
<TR><TH COLSPAN=3><HR>
</TABLE>

<P>
The WM_HINTS.flags bit definitions are as follows:
<TABLE>
<TR><TH COLSPAN=3><HR>
<TR><TH ALIGN=left>Name	<TH ALIGN=left>Value	<TH ALIGN=left>Field
<TR><TH COLSPAN=3><HR>
<TR><TD><B>InputHint</B>	<TD>1	<TD>input
<TR><TD><B>StateHint</B>	<TD>2	<TD>initial_state
<TR><TD><B>IconPixmapHint</B>	<TD>4	<TD>icon_pixmap
<TR><TD><B>IconWindowHint</B>	<TD>8	<TD>icon_window
<TR><TD><B>IconPositionHint</B>	<TD>16	<TD>icon_x & icon_y
<TR><TD><B>IconMaskHint</B>	<TD>32	<TD>icon_mask
<TR><TD><B>WindowGroupHint</B>	<TD>64	<TD>window_group
<TR><TD><B>MessageHint</B>	<TD>128	<TD>(this bit is obsolete)
<TR><TD><B>UrgencyHint</B>	<TD>256	<TD>urgency
<TR><TH COLSPAN=3><HR>
</TABLE>

<P>
Window managers are free to assume convenient values for all fields of
the WM_HINTS property if a window is mapped without one.
<P>
The input field is used to communicate to the window manager the input focus
model used by the client (see <A HREF="sec-4.html#s-4.1.7">section 4.1.7</A>).
<P>
Clients with the Globally Active and No Input models should set the
input flag to
<B>False .</B>
Clients with the Passive and Locally Active models should set the input
flag to
<B>True .</B>
<P>
From the client's point of view, 
the window manager will regard the client's top-level window as being 
in one of three states:
<UL>
<LI> Normal
<LI> Iconic
<LI> Withdrawn
</UL>
The semantics of these states are described in <A HREF="sec-4.html#s-4.1.4">section 4.1.4</A>.
Newly created windows start in the Withdrawn state.
Transitions between states happen when a
top-level window is mapped and unmapped
and when the window manager receives certain messages.
<P>
The value of the initial_state field determines the state the client
wishes to be in at the time the top-level window is mapped 
from the Withdrawn state, as shown in the following table:
<TABLE>
<TR><TH COLSPAN=3><HR>
<TR><TH ALIGN=left>State	<TH ALIGN=left>Value	<TH ALIGN=left>Comments
<TR><TH COLSPAN=3><HR>
<TR><TD><B>NormalState</B>	<TD>1	<TD>The window is visible
<TR><TD><B>IconicState</B>	<TD>3	<TD>The icon is visible
<TR><TH COLSPAN=3><HR>
</TABLE>

<P>
The icon_pixmap field may specify a pixmap to be used as an icon.
This pixmap should be:
<UL>
<LI> One of the sizes specified in the WM_ICON_SIZE property 
on the root if it exists (see <A HREF="sec-4.html#s-4.1.3.2">section 4.1.3.2</A>).
<LI> 1-bit deep.
The window manager will select, through the defaults database,
suitable background (for the 0 bits) and foreground (for the 1 bits) colors.
These defaults can, of course, specify different colors for the icons 
of different clients.
</UL>
The icon_mask specifies which pixels of the icon_pixmap should be used as the
icon, allowing for icons to appear nonrectangular.
<P>
The icon_window field is the ID of a window the client wants used as its icon.
Most, but not all, window managers will support icon windows.
Those that do not are likely to have a user interface in which small
windows that behave like icons are completely inappropriate.
Clients should not attempt to remedy the omission by working around it.
<P>
Clients that need more capabilities from the icons than a simple two-color
bitmap should use icon windows.
Rules for clients that do are set out in <A HREF="sec-4.html#s-4.1.9">section 4.1.9</A>.
<P>
The (icon_x,icon_y) coordinate is a hint to the window manager 
as to where it should position the icon.
The policies of the window manager control the positioning of icons,
so clients should not depend on attention being paid to this hint.
<P>
The window_group field lets the client specify that this window belongs 
to a group of windows.
An example is a single client manipulating multiple 
children of the root window.
<OL>
<P ALIGN=center> Conventions<P>
<LI> The window_group field should be set to the ID of the group leader.
The window group leader may be a window that exists only for that purpose;
a placeholder group leader of this kind would never be mapped
either by the client or by the window manager.
<LI> The properties of the window group leader are those for the group as
a whole (for example, the icon to be shown when the entire group is iconified).
</OL>
<P>
Window managers may provide facilities for manipulating the group as a whole.
Clients, at present, have no way to operate on the group as a whole.
<P>
The messages bit, if set in the flags field, indicates that the
client is using an obsolete window manager communication protocol,<A HREF="footnotes.html#f-11"><SUP>11</SUP></A>

rather than the WM_PROTOCOLS mechanism of <A HREF="sec-4.html#s-4.1.2.7">section 4.1.2.7</A>.
<P>
The
<B>UrgencyHint</B>
flag, if set in the flags field, indicates that the client deems the window
contents to be urgent, requiring the timely response of the user.  The
window manager must make some effort to draw the user's attention to this
window while this flag is set.  The window manager must also monitor the
state of this flag for the entire time the window is in the Normal or Iconic
state and must take appropriate action when the state of the flag changes.
The flag is otherwise independent of the window's state; in particular, the
window manager is not required to deiconify the window if the client sets
the flag on an Iconic window.  Clients must provide some means by which the
user can cause the
<B>UrgencyHint</B>
flag to be set to zero or the window to be withdrawn.  The user's action can
either mitigate the actual condition that made the window urgent, or it can
merely shut off the alarm.
<P ALIGN=center> Rationale
<BLOCKQUOTE>
<P>This mechanism is useful for alarm dialog boxes or reminder windows, in
cases where mapping the window is not enough (e.g. in the presence of
multi-workspace or virtual desktop window managers), and where using an
override-redirect window is too intrusive.  For example, the window manager
may attract attention to an urgent window by adding an indicator to its
title bar or its icon.  Window managers may also take additional action
for a window that is newly urgent, such as by flashing its icon (if the
window is iconic) or by raising it to the top of the stack.
</BLOCKQUOTE>

<A NAME="WM_CLASS"></A>
<H4><A NAME="s-4.1.2.5">4.1.2.5.</A> WM_CLASS Property</H4>
The WM_CLASS property (of type STRING without control characters)
contains two consecutive null-terminated strings.
These specify the Instance and Class names to be used by both the client 
and the window manager for looking up resources for the application 
or as identifying information.
This property must be present when the window leaves the Withdrawn state
and may be changed only while the window is in the Withdrawn state.
Window managers may examine the property only when they start up 
and when the window leaves the Withdrawn state,
but there should be no need for a client to change its state dynamically.
<P>
The two strings, respectively, are:
<UL>
<LI> A string that names the particular instance of the application to which
the client that owns this window belongs.
Resources that are specified by instance name override any resources
that are specified by class name.
Instance names can be specified by the user in an operating-system specific 
manner.
On POSIX-conformant systems,
the following conventions are used:
<UL>
<LI> If &quot;-name NAME&quot; is given on the command line,
NAME is used as the instance name.
<LI> Otherwise, if the environment variable RESOURCE_NAME is set,
its value will be used as the instance name.
<LI> Otherwise,
the trailing part of the name used to invoke the program
(argv[0] stripped of any directory names) is used as the instance name.
</UL>
<LI> A string that names the general class of applications to which the client 
that owns this window belongs.
Resources that are specified by class apply to all applications 
that have the same class name.
Class names are specified by the application writer.
Examples of commonly used class names include: 
&quot;Emacs&quot;, &quot;XTerm&quot;, &quot;XClock&quot;, &quot;XLoad&quot;, and so on.
</UL>
Note that WM_CLASS strings are null-terminated
and, thus, differ from the general conventions that STRING properties 
are null-separated.
This inconsistency is necessary for backwards compatibility.

<A NAME="WM_TRANSIENT_FOR"></A>
<H4><A NAME="s-4.1.2.6">4.1.2.6.</A> WM_TRANSIENT_FOR Property</H4>
The WM_TRANSIENT_FOR property (of type WINDOW)
contains the ID of another top-level window.
The implication is that this window is a pop-up on behalf of the named window,
and window managers may decide not to decorate transient windows
or may treat them differently in other ways.
In particular,
window managers should present newly mapped WM_TRANSIENT_FOR
windows without requiring any user interaction,
even if mapping top-level windows normally does require interaction.
Dialogue boxes, for example, are an example of windows that should have
WM_TRANSIENT_FOR set.
<P>
It is important not to confuse WM_TRANSIENT_FOR with override-redirect.
WM_TRANSIENT_FOR should be used in those cases where the pointer
is not grabbed while the window is mapped (in other words, 
if other windows are allowed to be active while the transient is up).
If other windows must be prevented from processing input
(for example, when implementing pop-up menus),
use override-redirect and grab the pointer while the window is mapped.

<A NAME="WM_PROTOCOLS"></A>
<H4><A NAME="s-4.1.2.7">4.1.2.7.</A> WM_PROTOCOLS Property</H4>
The WM_PROTOCOLS property (of type ATOM) is a list of atoms.
Each atom identifies a communication protocol between the client 
and the window manager in which the client is willing to participate.
Atoms can identify both standard protocols and private protocols
specific to individual window managers.
<P>
All the protocols in which a client can volunteer to take part 
involve the window manager sending the client a 
<B>ClientMessage</B>
event and the client taking appropriate action.
For details of the contents of the event,
see <A HREF="sec-4.html#s-4.2.8">section 4.2.8</A>.
In each case,
the protocol transactions are initiated by the window manager.
<P>
The WM_PROTOCOLS property is not required.
If it is not present,
the client does not want to participate in any window manager protocols.
<P>
The X Consortium will maintain a registry of protocols to avoid collisions 
in the name space.
The following table lists the protocols that have been defined to date.
<TABLE>
<TR><TH COLSPAN=3><HR>
<TR><TH ALIGN=left>Protocol	<TH ALIGN=left>Section	<TH ALIGN=left>Purpose
<TR><TH COLSPAN=3><HR>
<TR><TD>WM_TAKE_FOCUS	<TD><A HREF="sec-4.html#s-4.1.7">4.1.7</A>	<TD>Assignment of input focus
<TR><TD>WM_SAVE_YOURSELF	<TD><A HREF="sec-C.html#s-C">Appendix C</A>	<TD>Save client state request (deprecated)
<TR><TD>WM_DELETE_WINDOW	<TD><A HREF="sec-4.html#s-4.2.8.1">4.2.8.1</A>	<TD>Request to delete top-level window
<TR><TH COLSPAN=3><HR>
</TABLE>

It is expected that this table will grow over time.

<A NAME="WM_COLORMAP_WINDOWS"></A>
<H4><A NAME="s-4.1.2.8">4.1.2.8.</A> WM_COLORMAP_WINDOWS Property</H4>
The WM_COLORMAP_WINDOWS property (of type WINDOW) on a top-level window 
is a list of the IDs of windows that may need colormaps installed
that differ from the colormap of the top-level window.
The window manager will watch this list of windows for changes in their
colormap attributes.
The top-level window is always (implicitly or explicitly) on the watch list.
For the details of this mechanism,
see <A HREF="sec-4.html#s-4.1.8">section 4.1.8</A>.

<A NAME="WM_CLIENT_MACHINE"></A>
<H4><A NAME="s-4.1.2.9">4.1.2.9.</A> WM_CLIENT_MACHINE Property</H4>
The client should set the WM_CLIENT_MACHINE property (of one of the TEXT
types) to a string that forms the name of the machine running the client as
seen from the machine running the server.

<H3><A NAME="s-4.1.3">4.1.3.</A> Window Manager Properties</H3>
The properties that were described in the previous section are those 
that the client is responsible for maintaining on its top-level windows.
This section describes the properties that the window manager places on
client's top-level windows and on the root.

<A NAME="WM_STATE"></A>
<H4><A NAME="s-4.1.3.1">4.1.3.1.</A> WM_STATE Property</H4>
The window manager will place a WM_STATE property (of type WM_STATE) on each
top-level client window that is not in the Withdrawn state.  Top-level
windows in the Withdrawn state may or may not have the WM_STATE property.
Once the top-level window has been withdrawn, the client may re-use it for
another purpose.  Clients that do so should remove the WM_STATE property if
it is still present.
<P>
Some clients (such as <B>xprop</B>) will ask the user to click over a window
on which the program is to operate.  Typically, the intent is for this to be
a top-level window.  To find a top-level window, clients should search the
window hierarchy beneath the selected location for a window with the
WM_STATE property.  This search must be recursive in order to cover all
window manager reparenting possibilities.  If no window with a WM_STATE
property is found, it is recommended that programs use a mapped
child-of-root window if one is present beneath the selected location.
<P>
The contents of the WM_STATE property are defined as follows:
<TABLE>
<TR><TH COLSPAN=3><HR>
<TR><TH ALIGN=left>Field	<TH ALIGN=left>Type	<TH ALIGN=left>Comments
<TR><TH COLSPAN=3><HR>
<TR><TD>state	<TD>CARD32	<TD>(see the next table)
<TR><TD>icon	<TD>WINDOW	<TD>ID of icon window
<TR><TH COLSPAN=3><HR>
</TABLE>

<P>
The following table lists the WM_STATE.state values:
<TABLE>
<TR><TH COLSPAN=2><HR>
<TR><TH ALIGN=left>State	<TH ALIGN=left>Value
<TR><TH COLSPAN=2><HR>
<TR><TD><B>WithdrawnState</B>	<TD>0
<TR><TD><B>NormalState</B>	<TD>1
<TR><TD><B>IconicState</B>	<TD>3
<TR><TH COLSPAN=2><HR>
</TABLE>

<P>
Adding other fields to this property is reserved to the X Consortium.
Values for the state field other than those defined in the above
table are reserved for use by X Consortium.
<P>
The state field describes the window manager's idea of the state 
the window is in, which may not match the client's idea as expressed 
in the initial_state field of the WM_HINTS property 
(for example, if the user has asked the window manager to iconify the window).
If it is 
<B>NormalState ,</B>
the window manager believes the client should be animating its window.
If it is 
<B>IconicState ,</B>
the client should animate its icon window.
In either state,
clients should be prepared to handle exposure events from either window.
<P>
When the window is withdrawn, the window manager will either change the
state field's value to
<B>WithdrawnState</B>
or it will remove the WM_STATE property entirely.
<P>
The icon field should contain the window ID of the window that the
window manager uses as the icon for the window on which this property is
set.  If no such window exists, the icon field should be
<B>None .</B>
Note that this window could be but is not necessarily the same window as the
icon window that the client may have specified in its WM_HINTS property.
The WM_STATE icon may be a window that the window manager has supplied and
that contains the client's icon pixmap, or it may be an ancestor of the
client's icon window.

<A NAME="WM_ICON_SIZE"></A>
<H4><A NAME="s-4.1.3.2">4.1.3.2.</A> WM_ICON_SIZE Property</H4>
A window manager that wishes to place constraints on the sizes of icon
pixmaps and/or windows should place a property called WM_ICON_SIZE on the root.
The contents of this property are listed in the following table. 
<TABLE>
<TR><TH COLSPAN=3><HR>
<TR><TH ALIGN=left>Field	<TH ALIGN=left>Type	<TH ALIGN=left>Comments
<TR><TH COLSPAN=3><HR>
<TR><TD>max_width	<TD>CARD32
<TR><TD>max_height	<TD>CARD32
<TR><TD>width_inc	<TD>CARD32
<TR><TD>height_inc	<TD>CARD32
<TR><TH COLSPAN=3><HR>
</TABLE>

<P>
For more details see <A HREF="/gui/x/xlib/ICC/client-to-window-manager/wm-icon-size.html">section 14.1.12 in <I>Xlib - C Language X Interface</I></A>.

<H3><A NAME="s-4.1.4">4.1.4.</A> Changing Window State</H3>
From the client's point of view,
the window manager will regard each of the client's top-level 
windows as being in one of three states,
whose semantics are as follows:
<UL>
<LI> <B>NormalState</B>
- The client's top-level window is viewable.
<LI> <B>IconicState</B>
- The client's top-level window is iconic
(whatever that means for this window manager).
The client can assume that its top-level window is not viewable,
its icon_window (if any) will be viewable
and, failing that, 
its icon_pixmap (if any) or its WM_ICON_NAME will be displayed.
<LI> <B>WithdrawnState</B>
- Neither the client's top-level window nor its icon is visible.
</UL>
In fact,
the window manager may implement states with semantics 
other than those described above.
For example,
a window manager might implement a concept of an &quot;inactive&quot; state
in which an infrequently used client's window would be represented 
as a string in a menu.
But this state is invisible to the client,
which would see itself merely as being in the Iconic state.
<P>
Newly created top-level windows are in the Withdrawn state.
Once the window has been provided with suitable properties,
the client is free to change its state as follows:
<UL>
<LI> Withdrawn -> Normal - The client should map the window with 
WM_HINTS.initial_state being 
<B>NormalState .</B>
<LI> Withdrawn -> Iconic - The client should map the window with 
WM_HINTS.initial_state being 
<B>IconicState .</B>
<LI> Normal -> Iconic - The client should send a
<B>ClientMessage</B>
event as described later in this section.
<LI> Normal -> Withdrawn - The client should unmap the window and follow it 
with a synthetic 
<B>UnmapNotify</B>
event as described later in this section.
<LI> Iconic -> Normal - The client should map the window.
The contents of WM_HINTS.initial_state are irrelevant in this case.
<LI> Iconic -> Withdrawn - The client should unmap the window 
and follow it with a synthetic 
<B>UnmapNotify</B>
event as described later in this section.
</UL>
Only the client can effect a transition into or out of the Withdrawn
state.
Once a client's window
has left the Withdrawn state,
the window will be mapped if it is in the Normal state and the window will be
unmapped if it is in the Iconic state.  Reparenting window managers
must unmap the client's window when it is in the Iconic state, even if an
ancestor window being unmapped renders the client's window unviewable.
Conversely, if a reparenting window manager renders the client's window
unviewable by unmapping an ancestor, the client's window is by definition in
the Iconic state and must also be unmapped.
<P ALIGN=center>Advice to Implementors
<BLOCKQUOTE>
<P>Clients can select for
<B>StructureNotify</B>
on their
top-level windows to track transitions between Normal and Iconic states.
Receipt of a
<B>MapNotify</B>
event will indicate a transition to the Normal state, and receipt of an
<B>UnmapNotify</B>
event will indicate a transition to the Iconic state.
</BLOCKQUOTE>
<P>
When changing the state of the window to Withdrawn, the client must (in
addition to unmapping the window) send a synthetic
<B>UnmapNotify</B>
event by
using a
<B>SendEvent</B>
request with the following arguments:
<TABLE>
<TR><TH COLSPAN=2><HR>
<TR><TH ALIGN=left>Argument	<TH ALIGN=left>Value
<TR><TH COLSPAN=2><HR>
<TR><TD>destination:	<TD>The root
<TR><TD>propagate:	<TD><B>False</B>
<TR><TD>event-mask:	<TD><B>( SubstructureRedirect|SubstructureNotify )</B>
<TR><TD>event: an <B>UnmapNotify</B> with:	<TD>
<TR><TD>event:	<TD>The root
<TR><TD>window:	<TD>The window itself
<TR><TD>from-configure:	<TD><B>False</B>
<TR><TH COLSPAN=2><HR>
</TABLE>

<P ALIGN=center> Rationale
<BLOCKQUOTE>
<P>The reason for requiring the client to send a synthetic
<B>UnmapNotify</B>
event is to ensure that the window manager
gets some notification of the client's desire to change state,
even though the window may already be unmapped when the desire is expressed.
</BLOCKQUOTE>
<P ALIGN=center>Advice to Implementors
<BLOCKQUOTE>
<P>For compatibility with obsolete clients, 
window managers should trigger the transition to the Withdrawn state
on the real 
<B>UnmapNotify</B>
rather than waiting for the synthetic one.
They should also trigger the transition if they receive a synthetic 
<B>UnmapNotify</B>
on a window for which they have not yet received a real 
<B>UnmapNotify .</B>
</BLOCKQUOTE>
<P>
When a client withdraws a window,
the window manager will then update or remove the WM_STATE
property as described in <A HREF="sec-4.html#s-4.1.3.1">section 4.1.3.1</A>.
Clients that want to re-use a client window (e.g. by mapping it again or
reparenting it elsewhere) after withdrawing it must wait for the
withdrawal to be complete before proceeding.  The preferred method for
doing this is for clients to wait for the window manager to update or
remove the WM_STATE property.<A HREF="footnotes.html#f-12"><SUP>12</SUP></A>

<P>
If the transition is from the Normal to the Iconic state,
the client should send a 
<B>ClientMessage </B>
event to the root with:
<UL>
<LI> Window == the window to be iconified
<LI> Type<A HREF="footnotes.html#f-13"><SUP>13</SUP></A>
 == the atom WM_CHANGE_STATE
<LI> Format == 32
<LI> Data[0] == IconicState
</UL>
<P ALIGN=center> Rationale
<BLOCKQUOTE>
<P>The format of this 
<B>ClientMessage </B>
event does not match the format of 
<B>ClientMessages</B>
in <A HREF="sec-4.html#s-4.2.8">section 4.2.8</A>.
This is because they are sent by the window manager to clients,
and this message is sent by clients to the window manager.
</BLOCKQUOTE>
<P>
Other values of data[0] are reserved for future extensions to these
conventions.  The parameters of the 
<B>SendEvent </B>
request should be those described for the synthetic
<B>UnmapNotify</B>
event.
<P ALIGN=center>Advice to Implementors
<BLOCKQUOTE>
<P>Clients can also select for 
<B>VisibilityChange</B>
events on their top-level or icon windows.
They will then receive a 
<B>VisibilityNotify (state==FullyObscured)</B>
event when the window concerned becomes completely
obscured even though mapped (and thus, perhaps a waste
of time to update) and a 
<B>VisibilityNotify (state!=FullyObscured)</B>
event when it becomes even partly viewable.
</BLOCKQUOTE>
<P ALIGN=center>Advice to Implementors
<BLOCKQUOTE>
<P>When a window makes a transition from the Normal state to either the Iconic
or to the Withdrawn state, clients should be aware that the window manager
may make transients for this window inaccessible.  Clients should not rely
on transient windows being available to the user when the transient owner
window is not in the Normal state.  When withdrawing a window, clients are
advised to withdraw transients for the window.
</BLOCKQUOTE>

<H3><A NAME="s-4.1.5">4.1.5.</A> Configuring the Window</H3>
Clients can resize and reposition their top-level windows by using the 
<B>ConfigureWindow </B>
request.
The attributes of the window that can be altered 
with this request are as follows:
<UL>
<LI> The [x,y] location of the window's upper left-outer corner
<LI> The [width,height] of the inner region of the window (excluding
borders)
<LI> The border width of the window
<LI> The window's position in the stack
</UL>
The coordinate system in which the location is expressed is that of the root
(irrespective of any reparenting that may have occurred).
The border width to be used and win_gravity position hint
to be used are those most recently requested by the client.
Client configure requests are interpreted by the window manager
in the same manner as the initial window geometry mapped from
the Withdrawn state, as described in <A HREF="sec-4.html#s-4.1.2.3">section 4.1.2.3</A>.
Clients must be aware that there is no guarantee that the window manager
will allocate them the requested size or location and must be prepared to
deal with any size and location.
If the window manager decides to respond to a 
<B>ConfigureRequest</B>
request by:
<UL>
<P>
<LI> Not changing the size, location, border width, or stacking order
of the window at all.

<P>

A client will receive a synthetic 
<B>ConfigureNotify</B>
event that describes the (unchanged) geometry of the window.
The (x,y) coordinates will be in the root coordinate system,
adjusted for the border width the client requested,
irrespective of any reparenting that has taken place.
The border_width will be the border width the client requested.
The client will not receive a real
<B>ConfigureNotify</B>
event because no change has actually taken place.

<P>

<LI> Moving or restacking the window without resizing it or
changing its border width.

<P>

A client will receive a synthetic 
<B>ConfigureNotify </B>
event following the change that describes the new geometry of the window.
The event's (x,y) coordinates will be in the root coordinate system adjusted 
for the border width the client requested.
The border_width will be the border width the client requested.
The client may not receive a real 
<B>ConfigureNotify</B>
event that describes this change because the window manager may have reparented
the top-level window.
If the client does receive a real event,
the synthetic event will follow the real one.

<P>

<LI> Resizing the window or changing its border width (regardless of whether the
window was also moved or restacked).

<P>

A client that has selected for 
<B>StructureNotify</B>
events will receive a real
<B>ConfigureNotify</B>
event.
Note that the coordinates in this event are relative to the parent,
which may not be the root if the window has been reparented.
The coordinates will reflect the actual border width of the window
(which the window manager may have changed).
The 
<B>TranslateCoordinates</B>
request can be used to convert the coordinates if required.
</UL>

The general rule is that coordinates in real 
<B>ConfigureNotify</B>
events are in the parent's space; 
in synthetic events, they are in the root space.
<P ALIGN=center>Advice to Implementors
<BLOCKQUOTE>
<P>Clients cannot distinguish between the case where a top-level window is
resized and moved from the case where the window is resized but not moved,
since a real
<B>ConfigureNotify</B>
event will be received in both cases.  Clients that are concerned with
keeping track of the absolute position of a top-level window should keep a
piece of state indicating whether they are certain of its position.  Upon
receipt of a real
<B>ConfigureNotify</B>
event on the top-level window, the client should note that the position is
unknown.  Upon receipt of a synthetic
<B>ConfigureNotify</B>
event, the client should note the position as known, using the position in
this event.  If the client receives a
<B>KeyPress ,</B>
<B>KeyRelease ,</B>
<B>ButtonPress ,</B>
<B>ButtonRelease ,</B>
<B>MotionNotify ,</B>
<B>EnterNotify ,</B>
or
<B>LeaveNotify</B>
event on the window (or on any descendant), the client can deduce the
top-level window's position from the difference between the (event-x,
event-y) and (root-x, root-y) coordinates in these events.  Only when the
position is unknown does the client need to use the
<B>TranslateCoordinates</B>
request to find the position of a top-level window.
</BLOCKQUOTE>
<P>
Clients should be aware that their borders may not be visible.
Window managers are free to use reparenting techniques to
decorate client's top-level windows with borders containing
titles,  controls, and other details to maintain a consistent look-and-feel.
If they do,
they are likely to override the client's attempts to set the border width
and set it to zero.
Clients, therefore, should not depend on the top-level window's border 
being visible or use it to display any critical information.
Other window managers will allow the top-level windows border to
be visible.
<P ALIGN=center> Convention
<BLOCKQUOTE>
<P>Clients should set the desired value of the border-width attribute on all 
<B>ConfigureWindow</B>
requests to avoid a race condition.
</BLOCKQUOTE>
<P>
Clients that change their position in the stack must be aware 
that they may have been reparented,
which means that windows that used to be siblings no longer are.
Using a nonsibling as the sibling parameter on a 
<B>ConfigureWindow </B>
request will cause an error.
<P ALIGN=center> Convention
<BLOCKQUOTE>
<P>Clients that use a
<B>ConfigureWindow</B>
request to request a change in their position in the stack 
should do so using 
<B>None</B>
in the sibling field.
</BLOCKQUOTE>
<P>
Clients that must position themselves in the stack relative to some
window that was originally a sibling must do the 
<B>ConfigureWindow</B>
request (in case they are running under a nonreparenting window manager),
be prepared to deal with a resulting error,
and then follow with a synthetic 
<B>ConfigureRequest </B>
event by invoking a
<B>SendEvent</B>
request with the following arguments:
<TABLE>
<TR><TH COLSPAN=2><HR>
<TR><TH ALIGN=left>Argument	<TH ALIGN=left>Value
<TR><TH COLSPAN=2><HR>
<TR><TD>destination:	<TD>The root
<TR><TD>propagate:	<TD><B>False</B>
<TR><TD>event-mask:	<TD><B>( SubstructureRedirect|SubstructureNotify )</B>
<TR><TD>event: a <B>ConfigureRequest </B> with:	<TD>
<TR><TD> event:	<TD>The root
<TR><TD> window:	<TD>The window itself
<TR><TD> ...	<TD>Other parameters from the <B>ConfigureWindow</B> request
<TR><TH COLSPAN=2><HR>
</TABLE>

<P>
Window managers are in any case free to position windows in the stack as
they see fit, and so clients should not rely on receiving the stacking
order they have requested.  Clients should ignore the above-sibling
field of both real and synthetic
<B>ConfigureNotify</B>
events received on their top-level windows because this field may not
contain useful information.

<H3><A NAME="s-4.1.6">4.1.6.</A> Changing Window Attributes</H3>
The attributes that may be supplied when a window is created may be
changed by using the 
<B>ChangeWindowAttributes</B>
request.
The window attributes are listed in the following table.
<TABLE>
<TR><TH COLSPAN=2><HR>
<TR><TH ALIGN=left>Attribute	<TH ALIGN=left>Private to Client
<TR><TH COLSPAN=2><HR>
<TR><TD>Background pixmap	<TD>Yes
<TR><TD>Background pixel	<TD>Yes
<TR><TD>Border pixmap	<TD>Yes
<TR><TD>Border pixel	<TD>Yes
<TR><TD>Bit gravity	<TD>Yes
<TR><TD>Backing-store hint	<TD>Yes
<TR><TD>Save-under hint	<TD>No
<TR><TD>Event mask	<TD>No
<TR><TD>Do-not-propagate mask	<TD>Yes
<TR><TD>Override-redirect flag	<TD>No
<TR><TD>Colormap	<TD>Yes
<TR><TD>Cursor	<TD>Yes
<TR><TH COLSPAN=2><HR>
</TABLE>

<P>
Most attributes are private to the client and will never be interfered with
by the window manager.
For the attributes that are not private to the client:
<UL>
<LI> The window manager is free to override the window gravity;
a reparenting window manager may want to set the top-level window's
window gravity for its own purposes.
<LI> Clients are free to set the save-under hint on their top-level windows,
but they must be aware that the hint may be overridden by the window manager.
<LI> Windows, in effect, have per-client event masks,
and so, clients may select for whatever events are convenient irrespective 
of any events the window manager is selecting for.
There are some events for which only one client at a time may select,
but the window manager should not select for them on any of the client's
windows.
<LI> Clients can set override-redirect on top-level windows but are
encouraged not to do so except as described in sections <A HREF="sec-4.html#s-4.1.10">4.1.10</A> and <A HREF="sec-4.html#s-4.2.9">4.2.9</A>.

</UL>
<H3><A NAME="s-4.1.7">4.1.7.</A> Input Focus</H3>
There are four models of input handling:
<UL>
<LI> No Input - The client never expects keyboard input.
An example would be 
<B>xload</B>
or another output-only client.
<LI> Passive Input - The client expects keyboard input but never explicitly sets 
the input focus.
An example would be a simple client with no subwindows,
which will accept input in 
<B>PointerRoot</B>
mode or when the window manager sets the input focus to its top-level window 
(in click-to-type mode).
<LI> Locally Active Input - The client expects keyboard input and explicitly sets 
the input focus, 
but it only does so when one of its windows already has the focus.
An example would be a client with subwindows defining various data
entry fields that uses Next and Prev keys to move the input focus
between the fields.
It does so when its top-level window has acquired the focus in 
<B>PointerRoot</B>
mode or when the window manager sets the input focus to its top-level window 
(in click-to-type mode).
<LI> Globally Active Input - The client expects keyboard input and explicitly sets 
the input focus, 
even when it is in windows the client does not own.
An example would be a client with a scroll bar that wants to allow
users to scroll the window without disturbing the input focus even if
it is in some other window.
It wants to acquire the input focus when the user clicks in the scrolled
region but not when the user clicks in the scroll bar itself.
Thus, it wants to prevent the window manager from setting the input focus 
to any of its windows.
</UL>
The four input models and the corresponding values of the input field
and the presence or absence of the WM_TAKE_FOCUS atom in the
WM_PROTOCOLS property are listed in the following table:
<TABLE>
<TR><TH COLSPAN=3><HR>
<TR><TH ALIGN=left>Input Model	<TH ALIGN=left>Input Field	<TH ALIGN=left>WM_TAKE_FOCUS
<TR><TH COLSPAN=3><HR>
<TR><TD>No Input	<TD><B>False</B>	<TD>Absent
<TR><TD>Passive	<TD><B>True</B>	<TD>Absent
<TR><TD>Locally Active	<TD><B>True</B>	<TD>Present
<TR><TD>Globally Active	<TD><B>False</B>	<TD>Present
<TR><TH COLSPAN=3><HR>
</TABLE>

<P>
Passive and Locally Active clients set the input field of WM_HINTS to
<B>True ,</B>
which indicates that they require window manager assistance  in acquiring the
input focus.
No Input and Globally Active clients set the input field to
<B>False ,</B>
which requests that the window manager not set the input focus 
to their top-level window.
<P>
Clients that use a
<B>SetInputFocus</B>
request must set the time field to the timestamp of the event 
that caused them to make the attempt.
This cannot be a 
<B>FocusIn</B>
event because they do not have timestamps.
Clients may also acquire 
the focus without a corresponding 
<B>EnterNotify .</B>
Note that clients must not use 
<B>CurrentTime </B>
in the time field.
<P>
Clients using the Globally Active model can only use a
<B>SetInputFocus</B>
request to acquire the input focus when they do not already have it on
receipt of one of the following events:
<UL>
<LI> <B>ButtonPress</B>
<LI> <B>ButtonRelease</B>
<LI> Passive-grabbed 
<B>KeyPress</B>
<LI> Passive-grabbed
<B>KeyRelease</B>
</UL>
In general,
clients should avoid using passive-grabbed key events for this purpose,
except when they are unavoidable (as, for example, a selection tool 
that establishes a passive grab on the keys that cut,  copy,  or paste).
<P>
The method by which the user commands the window manager to
set the focus to a window is up to the window manager.
For example, 
clients cannot determine whether they will see the click 
that transfers the focus.
<P>
Windows with the atom WM_TAKE_FOCUS in their WM_PROTOCOLS property
may receive a 
<B>ClientMessage </B>
event from the window manager (as described in <A HREF="sec-4.html#s-4.2.8">section 4.2.8</A>)
with WM_TAKE_FOCUS in its data[0] field and a valid timestamp
(i.e. not
<B>CurrentTime )</B>
in its data[1] field.
If they want the focus,
they should respond with a 
<B>SetInputFocus</B>
request with its window field set to the window of theirs 
that last had the input focus or to their default input window,
and the time field set to the timestamp in the message.
For further information,
see <A HREF="sec-4.html#s-4.2.7">section 4.2.7</A>.
<P>
A client could receive WM_TAKE_FOCUS when opening from an icon
or when the user has clicked outside the top-level window in an area that
indicates to the window manager that it should assign the focus 
(for example, clicking in the headline bar can be used to assign the focus).
<P>
The goal is to support window managers that want to assign the input focus
to a top-level window in such a way that the top-level window either
can assign it to one of its subwindows or can decline the offer of the focus.
For example, a clock or a text editor with no currently open frames 
might not want to take focus even though the window manager generally 
believes that clients should take the input focus after being deiconified 
or raised.
<P>
Clients that set the input focus need to decide a value for the
revert-to field of the 
<B>SetInputFocus</B>
request.
This determines the behavior of the input focus 
if the window the focus has been set to becomes not viewable.
The value can be any of the following:
<UL>
<LI> <B>Parent</B>
- In general, 
clients should use this value when assigning focus to one of their subwindows.
Unmapping the subwindow will cause focus to revert to the parent,
which is probably what you want.
<LI> <B>PointerRoot </B>
- Using
this value with a click-to-type focus management policy
leads to race conditions because the window becoming unviewable may
coincide with the window manager deciding to move the focus elsewhere.
<LI> <B>None </B>
- Using
this value causes problems if the window manager reparents 
the window, as most window managers will, and then crashes.
The input focus will be 
<B>None , </B>
and there will probably be no way to change it.
</UL>
Note that neither
<B>PointerRoot</B>
nor
<B>None</B>
is really safe to use.
<P ALIGN=center> Convention
<BLOCKQUOTE>
<P>Clients that invoke a
<B>SetInputFocus </B>
request should set the revert-to argument to 
<B>Parent .</B>
</BLOCKQUOTE>
<P>
A convention is also required for clients that want to give up the
input focus.
There is no safe value set for them to set the input focus to;
therefore, they should ignore input material.
<P ALIGN=center> Convention
<BLOCKQUOTE>
<P>Clients should not give up the input focus of their own volition.
They should ignore input that they receive instead.
</BLOCKQUOTE>

<H3><A NAME="s-4.1.8">4.1.8.</A> Colormaps</H3>
The window manager is responsible for installing and uninstalling 
colormaps on behalf of clients with top-level windows that
the window manager manages.
<P>
Clients provide the window manager with hints as to which colormaps to
install and uninstall.  Clients must not install or uninstall colormaps
themselves (except under the circumstances noted below).  When a client's
top-level window gets the colormap focus (as a result of whatever colormap
focus policy is implemented by the window manager), the window manager will
ensure that one or more of the client's colormaps are installed.
<P>
Clients whose top-level windows and subwindows all use the same colormap
should set its ID in the colormap field of the top-level window's
attributes.  They should not set a WM_COLORMAP_WINDOWS property on the
top-level window.  If they want to change the colormap, they should change
the top-level window's colormap attribute.  The window manager will track
changes to the window's colormap attribute and install colormaps as
appropriate.
<P>
Clients that create windows can use the value 
<B>CopyFromParent</B>
to inherit their parent's colormap.  Window managers will ensure that the
root window's colormap field contains a colormap that is suitable for
clients to inherit.  In particular, the colormap will provide
distinguishable colors for
<B>BlackPixel </B>
and 
<B>WhitePixel .</B>
<P>
Top-level windows that have subwindows or override-redirect pop-up windows
whose colormap requirements differ from the top-level window should have a
WM_COLORMAP_WINDOWS property.  This property contains a list of IDs for
windows whose colormaps the window manager should attempt to have installed
when, in the course of its individual colormap focus policy, it assigns the
colormap focus to the top-level window (see <A HREF="sec-4.html#s-4.1.2.8">section 4.1.2.8</A>).  The list is
ordered by the importance to the client of having the colormaps installed.
The window manager will track changes to this property and will track
changes to the colormap attribute of the windows in the property.
<P>
If the relative importance of colormaps changes, the client should update
the WM_COLORMAP_WINDOWS property to reflect the new ordering.  If the
top-level window does not appear in the list, the window manager will assume
it to be of higher priority than any window in the list.
<P>
WM_TRANSIENT_FOR windows either can have their own WM_COLORMAP_WINDOWS
property or can appear in the property of the window they are transient for,
as appropriate.
<P ALIGN=center> Rationale
<BLOCKQUOTE>
<P>An alternative design was considered for how clients should hint to the
window manager about their colormap requirements.  This alternative design
specified a list of colormaps instead of a list of windows.  The current
design, a list of windows, was chosen for two reasons.  First, it allows
window managers to find the visuals of the colormaps, thus permitting
visual-dependent colormap installation policies.  Second, it allows window
managers to select for
<B>VisibilityChange</B>
events on the windows concerned and to ensure that colormaps are only
installed if the windows that need them are visible.  The alternative design
allows for neither of these policies.
</BLOCKQUOTE>
<P ALIGN=center>Advice to Implementors
<BLOCKQUOTE>
<P>Clients should be aware of the min-installed-maps and max-installed-maps
fields of the connection setup information, and the effect that the minimum
value has on the &quot;required list&quot; defined by the Protocol in the
description of the
<B>InstallColormap</B>
request.  Briefly, the min-installed-maps most recently installed maps are
guaranteed to be installed.  This value is often one; clients needing
multiple colormaps should beware.
</BLOCKQUOTE>
<P>
Whenever possible, clients should use the mechanisms described above and let
the window manager handle colormap installation.  However, clients are
permitted to perform colormap installation on their own while they have the
pointer grabbed.  A client performing colormap installation must notify the
window manager prior to the first installation.  When the client has
finished its colormap installation, it must also notify the window manager.
The client notifies the window manager by issuing a
<B>SendEvent</B>
request with the following arguments:
<TABLE>
<TR><TH COLSPAN=2><HR>
<TR><TH ALIGN=left>Argument	<TH ALIGN=left>Value
<TR><TH COLSPAN=2><HR>
<TR><TD>destination:	<TD>the root window of the screen on which the colormap is being installed
<TR><TD>propagate:	<TD><B>False</B>
<TR><TD>event-mask:	<TD><B>ColormapChange</B>
<TR><TD>event: a <B>ClientMessage</B> with:	<TD>
<TR><TD> window:	<TD>the root window, as above
<TR><TD> type:	<TD>WM_COLORMAP_NOTIFY
<TR><TD> format:	<TD>32
<TR><TD> data[0]:	<TD>the timestamp of the event that caused the client to start or stop installing colormaps
<TR><TD> data[1]:	<TD>1 if the client is starting colormap installation, 0 if the client is finished with colormap installation
<TR><TD> data[2]:	<TD>reserved, must be zero
<TR><TD> data[3]:	<TD>reserved, must be zero
<TR><TD> data[4]:	<TD>reserved, must be zero
<TR><TH COLSPAN=2><HR>
</TABLE>

<P>
This feature was introduced in version <A HREF="sec-2.html#s-2.0">2.0</A> of this document, and there will
be a significant period of time before all window managers can be expected
to implement this feature.  Before using this feature, clients must check
the compliance level of the window manager (using the mechanism described in
<A HREF="sec-4.html#s-4.3">section 4.3</A>) to verify that it supports this feature.  This is necessary to
prevent colormap installation conflicts between clients and older window
managers.
<P>
Window managers should refrain from installing colormaps while a client has
requested control of colormap installation.  The window manager should
continue to track the set of installed colormaps so that it can reinstate
its colormap focus policy when the client has finished colormap installation.
<P>
This technique has race conditions that may result in the colormaps
continuing to be installed even after a client has issued its notification
message.  For example, the window manager may have issued some
<B>InstallColormap</B>
requests that are not executed until after the
client's 
<B>SendEvent </B>
and
<B>InstallColormap</B>
requests, thus uninstalling the client's colormaps.  If this occurs while
the client still has the pointer grabbed and before the client has issued
the &quot;finished&quot; message, the client may reinstall the desired colormaps.
<P ALIGN=center>Advice to Implementors
<BLOCKQUOTE>
<P>Clients are expected to use this mechanism for things such as
popup windows and for animations that use override-redirect windows.
If a client fails to issue the &quot;finished&quot; message, the window manager
may be left in a state where its colormap installation policy is suspended.
Window manager implementors may want to implement a feature that resets
colormap installation policy in response to a command from the user.
</BLOCKQUOTE>

<H3><A NAME="s-4.1.9">4.1.9.</A> Icons</H3>
A client can hint to the window manager about the desired appearance 
of its icon by setting:
<UL>
<LI> A string in WM_ICON_NAME
<P>
All clients should do this  
because it provides a fallback for window managers whose ideas 
about icons differ widely from those of the client.
<LI> A 
<B>Pixmap </B>
into the icon_pixmap field of the WM_HINTS property
and possibly another into the icon_mask field 
<P>
The window manager is expected to display the pixmap masked by the mask.
The pixmap should be one of the sizes found in the WM_ICON_SIZE property
on the root.
If this property is not found,
the window manager is unlikely to display icon pixmaps.
Window managers usually will clip or tile pixmaps that do not match
WM_ICON_SIZE.
<LI> A window into the icon_window field of the WM_HINTS property
<P>
The window manager is expected to map that window whenever the client is
in the Iconic state.
In general,
the size of the icon window should be one of those specified in WM_ICON_SIZE 
on the root, if it exists.
Window managers are free to resize icon windows.
</UL>
In the Iconic state,
the window manager usually will ensure that:
<UL>
<LI> If the window's WM_HINTS.icon_window is set,
the window it names is visible.
<LI> If the window's WM_HINTS.icon_window is not set
but the window's WM_HINTS.icon_pixmap is set,
the pixmap it names is visible.
<LI> Otherwise,
the window's WM_ICON_NAME string is visible.
</UL>
Clients should observe the following conventions about their icon windows:
<OL>
<P ALIGN=center> Conventions<P>
<LI> The icon window should be an 
<B>InputOutput</B>
child of the root.
<LI> The icon window should be one of the sizes specified 
in the WM_ICON_SIZE property on the root.
<LI> The icon window should use the root visual and default colormap 
for the screen in question.
<LI> Clients should not map their icon windows.
<LI> Clients should not unmap their icon windows.
<LI> Clients should not configure their icon windows.
<LI> Clients should not set override-redirect on their icon windows
or select for 
<B>ResizeRedirect </B>
events on them.
<LI> Clients must not depend on being able to receive input events
by means of their icon windows.
<LI> Clients must not manipulate the borders of their icon windows.
<LI> Clients must select for 
<B>Exposure</B>
events on their icon window and repaint it when requested.
</OL>
<P>
Window managers will differ as to whether they support input events
to client's icon windows;
most will allow the client to receive some subset of the keys and buttons.
<P>
Window managers will ignore any WM_NAME, WM_ICON_NAME, WM_NORMAL_HINTS,
WM_HINTS, WM_CLASS, WM_TRANSIENT_FOR, WM_PROTOCOLS, WM_COLORMAP_WINDOWS,
WM_COMMAND, or WM_CLIENT_MACHINE
properties they find on icon windows.

<H3><A NAME="s-4.1.10">4.1.10.</A> Pop-up Windows</H3>
Clients that wish to pop up a window can do one of three things:
<OL>
They can create and map another normal top-level window,
which will get decorated and managed as normal by the window manager.
See the discussion of window groups that follows.
<LI> If the window will be visible for a relatively short time
and deserves a somewhat lighter treatment,
they can set the WM_TRANSIENT_FOR property.
They can expect less decoration but can set all the normal
window manager properties on the window.
An example would be a dialog box.
<LI> If the window will be visible for a very short time
and should not be decorated at all,
the client can set override-redirect on the window.
In general,
this should be done only if the pointer is grabbed while the window is mapped.
The window manager will never interfere with these windows,
which should be used with caution.
An example of an appropriate use is a pop-up menu.
</OL>
<P ALIGN=center>Advice to Implementors
<BLOCKQUOTE>
<P>The user will not be able to move, resize, restack, or transfer the input
focus to override-redirect windows, since the window manager is not managing
them.  If it is necessary for a client to receive keystrokes on an
override-redirect window, either the client must grab the keyboard, or the
client must have another top-level window that is not override-redirect and
that has selected the Locally Active or Globally Active focus model.  The
client may set the focus to the override-redirect window when the other
window receives a WM_TAKE_FOCUS message or one of the events listed in
<A HREF="sec-4.html#s-4.1.7">section 4.1.7</A> in the description of the Globally Active focus model.
</BLOCKQUOTE>
<P>
Window managers are free to decide if WM_TRANSIENT_FOR windows
should be iconified when the window they are transient for is.
Clients displaying WM_TRANSIENT_FOR windows that have 
(or request to have) the window they are transient for iconified
do not need to request that the same operation be performed
on the WM_TRANSIENT_FOR window;
the window manager will change its state if that is the policy it wishes 
to enforce.

<H3><A NAME="s-4.1.11">4.1.11.</A> Window Groups</H3>
A set of top-level windows that should be treated from the user's point of view
as related (even though they may belong to a number of clients) should be linked
together using the window_group field of the WM_HINTS structure.
<P>
One of the windows (that is, the one the others point to) 
will be the group leader and will carry the group as opposed 
to the individual properties.
Window managers may treat the group leader differently 
from other windows in the group.
For example,
group leaders may have the full set of decorations,
and other group members may have a restricted set.
<P>
It is not necessary that the client ever map the group leader;
it may be a window that exists solely as a placeholder.
<P>
It is up to the window manager to determine the policy 
for treating the windows in a group.
At present, 
there is no way for a client to request a group, 
as opposed to an individual, operation.

<H2><A NAME="s-4.2">4.2.</A> Client Responses to Window Manager Actions</H2>
The window manager performs a number of operations on client resources,
primarily on their top-level windows.
Clients must not try to fight this but may elect to receive notification 
of the window manager's operations.

<H3><A NAME="s-4.2.1">4.2.1.</A> Reparenting</H3>
Clients must be aware that some window managers will reparent 
their top-level windows
so that a window that was created as a child of the root will be displayed 
as a child of some window belonging to the window manager.
The effects that this reparenting will have on the client are as follows:
<UL>
<LI> The parent value returned by a 
<B>QueryTree</B>
request will no longer be the value supplied to the 
<B>CreateWindow </B>
request that created the reparented window.
There should be no need for the client to be aware of the identity 
of the window to which the top-level window has been reparented.
In particular,
a client that wishes to create further top-level windows should continue 
to use the root as the parent for these new windows.
<LI> The server will interpret the (x,y) coordinates in a 
<B>ConfigureWindow</B>
request in the new parent's coordinate space.
In fact, they usually will not be interpreted by the server
because a reparenting window manager usually will have intercepted
these operations (see <A HREF="sec-4.html#s-4.2.2">section 4.2.2</A>).
Clients should use the root coordinate space for these requests
(see <A HREF="sec-4.html#s-4.1.5">section 4.1.5</A>).
<LI> <B>ConfigureWindow</B>
requests that name a specific sibling window may fail because the window named,
which used to be a sibling, no longer is after the reparenting operation
(see <A HREF="sec-4.html#s-4.1.5">section 4.1.5</A>).
<LI> The (x,y) coordinates returned by a 
<B>GetGeometry</B>
request are in the parent's coordinate space 
and are thus not directly useful after a reparent operation.
<LI> A background of 
<B>ParentRelative</B>
will have unpredictable results.
<LI> A cursor of 
<B>None</B>
will have unpredictable results.
</UL>
Clients that want to be notified when they are reparented can select for
<B>StructureNotify</B>
events on their top-level window.
They will receive a 
<B>ReparentNotify</B>
event if and when reparenting takes place.
When a client withdraws a top-level window, the window manager will
reparent it back to the root window if the window had been reparented
elsewhere.
<P>
If the window manager reparents a client's window,
the reparented window will be placed in the save-set 
of the parent window.
This means that the reparented window will not be destroyed 
if the window manager terminates and will be remapped if it was unmapped.
Note that this applies to all client windows the window manager reparents,
including transient windows and client icon windows.

<H3><A NAME="s-4.2.2">4.2.2.</A> Redirection of Operations</H3>
Clients must be aware that some window managers will arrange 
for some client requests to be intercepted and redirected.
Redirected requests are not executed; 
they result instead in events being sent to the window manager,
which may decide to do nothing, to alter the arguments, 
or to perform the request on behalf of the client.
<P>
The possibility that a request may be redirected means 
that a client cannot assume that any redirectable request is actually
performed when the request is issued or is actually performed at all.
The requests that may be redirected are
<B>MapWindow ,</B>
<B>ConfigureWindow ,</B>
and
<B>CirculateWindow .</B>
<P ALIGN=center>Advice to Implementors
<BLOCKQUOTE>
<P>The following is incorrect because the 
<B>MapWindow</B>
request may be intercepted and the
<B>PolyLine</B>
output made to an unmapped window:
<P>
<PRE><CODE>
MapWindow A
PolyLine A GC <point> <point> ...
</CODE></PRE>
<P>
The client must wait for an 
<B>Expose</B>
event before drawing in the window.<A HREF="footnotes.html#f-14"><SUP>14</SUP></A>

<P>
This next example incorrectly assumes that the 
<B>ConfigureWindow</B>
request is actually executed with the arguments supplied:
<P>
<PRE><CODE>
ConfigureWindow width=N height=M
<output assuming window is N by M>
</CODE></PRE>
<P>
The client should select for
<B>StructureNotify</B>
on its window and monitor the window's size by tracking
<B>ConfigureNotify</B>
events.
<P>
Clients must be especially careful when attempting to set the focus to a
window that they have just mapped.  This sequence may result in an X
protocol error:
<P>
<PRE><CODE>
MapWindow B
SetInputFocus B
</CODE></PRE>
<P>
If the
<B>MapWindow</B>
request has been intercepted, the window will still be
unmapped, causing the
<B>SetInputFocus</B>
request to generate the error.  The solution to this problem is for clients
to select for
<B>VisibilityChange</B>
on the window and to delay the issuance of the
<B>SetInputFocus</B>
request until they have received a 
<B>VisibilityNotify</B>
event indicating that the window is visible.
<P>
This technique does not guarantee correct operation.  The user may have
iconified the window by the time the
<B>SetInputFocus</B>
request reaches the server, still causing an error.  Or, the window manager
may decide to map the window into Iconic state, in which case the window
will not be visible.  This will delay the generation of the
<B>VisibilityNotify</B>
event indefinitely.  Clients must be prepared to handle these cases.
</BLOCKQUOTE>
<P>
A window with the override-redirect bit set is immune from redirection,
but the bit should be set on top-level windows only in cases 
where other windows should be prevented from processing input
while the override-redirect window is mapped (see <A HREF="sec-4.html#s-4.1.10">section 4.1.10</A>)
and while responding to 
<B>ResizeRequest</B>
events (see <A HREF="sec-4.html#s-4.2.9">section 4.2.9</A>).
<P>
Clients that have no non-Withdrawn top-level windows 
and that map an override-redirect top-level window are taking over total
responsibility for the state of the system.
It is their responsibility to:
<UL>
<LI> Prevent any preexisting window manager from interfering with their activities
<LI> Restore the status quo exactly after they unmap the window
so that any preexisting window manager does not get confused
</UL>
In effect,  clients of this kind are acting as temporary window managers.
Doing so is strongly discouraged because these clients will be unaware
of the user interface policies the window manager is trying to maintain
and because their user interface behavior is likely to conflict with that of
less demanding clients.

<H3><A NAME="s-4.2.3">4.2.3.</A> Window Move</H3>
If the window manager moves a top-level window without changing its size,
the client will receive a synthetic 
<B>ConfigureNotify</B>
event following the move that describes the new location
in terms of the root coordinate space.
Clients must not respond to being moved by attempting to move
themselves to a better location.
<P>
Any real 
<B>ConfigureNotify</B>
event on a top-level window implies that the window's position 
on the root may have changed,
even though the event reports that the window's position 
in its parent is unchanged because the window may have been reparented.
Note that the coordinates in the event will not, in this case,
be directly useful.
<P>
The window manager will send these events by using a
<B>SendEvent</B>
request with the following arguments:
<TABLE>
<TR><TH COLSPAN=2><HR>
<TR><TH ALIGN=left>Argument	<TH ALIGN=left>Value
<TR><TH COLSPAN=2><HR>
<TR><TD>destination:	<TD>The client's window
<TR><TD>propagate:	<TD><B>False</B>
<TR><TD>event-mask:	<TD><B>StructureNotify</B>
<TR><TH COLSPAN=2><HR>
</TABLE>


<H3><A NAME="s-4.2.4">4.2.4.</A> Window Resize</H3>
The client can elect to receive notification of being resized by selecting for
<B>StructureNotify</B>
events on its top-level windows.
It will receive a 
<B>ConfigureNotify</B>
event.
The size information in the event will be correct,
but the location will be in the parent window (which may not be the root).
<P>
The response of the client to being resized should be to accept
the size it has been given and to do its best with it.
Clients must not respond to being resized by attempting to resize
themselves to a better size.
If the size is impossible to work with,
clients are free to request to change to the Iconic state.

<H3><A NAME="s-4.2.5">4.2.5.</A> Iconify and Deiconify</H3>
A top-level window that is not Withdrawn will be 
in the Normal state if it is mapped and in the Iconic state if it is unmapped.
This will be true even if the window has been reparented;
the window manager will unmap the window as well as its parent
when switching to the Iconic state.
<P>
The client can elect to be notified of these state changes by selecting for 
<B>StructureNotify </B>
events on the top-level window.
It will receive a
<B>UnmapNotify</B>
event when it goes Iconic and a
<B>MapNotify</B>
event when it goes Normal.

<H3><A NAME="s-4.2.6">4.2.6.</A> Colormap Change</H3>
Clients that wish to be notified of their colormaps being installed
or uninstalled should select for 
<B>ColormapNotify</B>
events on their top-level windows and on any windows they have named 
in WM_COLORMAP_WINDOWS properties on their top-level windows.
They will receive 
<B>ColormapNotify</B>
events with the new field FALSE when the colormap for that window 
is installed or uninstalled.

<H3><A NAME="s-4.2.7">4.2.7.</A> Input Focus</H3>
Clients can request notification that they have the input focus by selecting
for 
<B>FocusChange</B>
events on their top-level windows;
they will receive 
<B>FocusIn </B>
and 
<B>FocusOut</B>
events.
Clients that need to set the input focus to one of their
subwindows should not do so unless
they have set WM_TAKE_FOCUS in their WM_PROTOCOLS property 
and have done one of the following:
<UL>
<LI> Set the input field of WM_HINTS to 
<B>True</B>
and actually have the input focus in one of their top-level windows
<LI> Set the input field of WM_HINTS to 
<B>False</B>
and have received a suitable event as described in <A HREF="sec-4.html#s-4.1.7">section 4.1.7</A>
<LI> Have received a WM_TAKE_FOCUS message as described in <A HREF="sec-4.html#s-4.1.7">section 4.1.7</A>
</UL>
Clients should not warp the pointer in an attempt to transfer the focus;
they should set the focus and leave the pointer alone.
For further information,
see <A HREF="sec-6.html#s-6.2">section 6.2</A>.
<P>
Once a client satisfies these conditions,
it may transfer the focus to another of its windows by using the 
<B>SetInputFocus</B>
request, which is defined as follows:
<P>
<TABLE>
<CAPTION><B>SetInputFocus</B></CAPTION>
<TR><TD ALIGN=right><I>focus</I> :	<TD> WINDOW or
<B>PointerRoot</B>
or
<B>None</B>
<TR><TD ALIGN=right><I>revert-to</I> :	<TD>
<B>{ Parent ,</B>
<B>PointerRoot ,</B>
<B>None }</B>
<TR><TD ALIGN=right><I>time</I> :	<TD> TIMESTAMP or
<B>CurrentTime</B>
</TABLE>
<OL>
<P ALIGN=center> Conventions<P>
<LI> Clients that use a  
<B>SetInputFocus</B>
request must set the time argument to the timestamp of the event 
that caused them to make the attempt.
This cannot be a 
<B>FocusIn</B>
event because they do not have timestamps.
Clients may also acquire the focus without a corresponding 
<B>EnterNotify </B>
event.
Clients must not use 
<B>CurrentTime</B>
for the time argument.
<LI> Clients that use a  
<B>SetInputFocus</B>
request to set the focus to one of their windows must set 
the revert-to field to 
<B>Parent .</B>
</OL>

<H3><A NAME="s-4.2.8">4.2.8.</A> ClientMessage Events</H3>
There is no way for clients to prevent themselves being sent
<B>ClientMessage</B>
events.
<P>
Top-level windows with a WM_PROTOCOLS property may be sent 
<B>ClientMessage</B>
events specific to the protocols named by the atoms in the property 
(see <A HREF="sec-4.html#s-4.1.2.7">section 4.1.2.7</A>).
For all protocols, the 
<B>ClientMessage</B>
events have the following:
<UL>
<LI> WM_PROTOCOLS as the type field
<LI> Format 32
<LI> The atom that names their protocol in the data[0] field
<LI> A timestamp in their data[1] field
</UL>
The remaining fields of the event,
including the window field,
are determined by the protocol.
<P>
These events will be sent by using a
<B>SendEvent</B>
request with the following arguments:
<TABLE>
<TR><TH COLSPAN=2><HR>
<TR><TH ALIGN=left>Argument	<TH ALIGN=left>Value
<TR><TH COLSPAN=2><HR>
<TR><TD>destination:	<TD>The client's window
<TR><TD>propagate:	<TD><B>False</B>
<TR><TD>event-mask:	<TD>() empty
<TR><TD>event:	<TD>As specified by the protocol
<TR><TH COLSPAN=2><HR>
</TABLE>


<H4><A NAME="s-4.2.8.1">4.2.8.1.</A> Window Deletion</H4>
Clients, usually those with multiple top-level windows, whose server
connection must survive the deletion of some of their top-level windows,
should include the atom WM_DELETE_WINDOW in the WM_PROTOCOLS property on
each such window.  They will receive a
<B>ClientMessage </B>
event as described above whose data[0] field is WM_DELETE_WINDOW.
<P>
Clients receiving a WM_DELETE_WINDOW message should behave as if the user
selected &quot;delete window&quot; from a hypothetical menu.
They should perform any confirmation dialog with the user
and, if they decide to complete the deletion, should do the following:
<UL>
<LI> Either change the window's state to Withdrawn (as described in <A HREF="sec-4.html#s-4.1.4">section 4.1.4</A>)
or destroy the window
<LI> Destroy any internal state associated with the window
</UL>
If the user aborts the deletion during the confirmation dialog,
the client should ignore the message.
<P>
Clients are permitted to interact with the user and ask, for example,
whether a file associated with the window to be deleted should be saved
or the window deletion should be cancelled.
Clients are not required to destroy the window itself;
the resource may be reused,
but all associated state (for example, backing store) should be released.
<P>
If the client aborts a destroy and the user then selects DELETE WINDOW again,
the window manager should start the WM_DELETE_WINDOW protocol again.
Window managers should not use 
<B>DestroyWindow</B>
requests on a window that has WM_DELETE_WINDOW in its WM_PROTOCOLS property.
<P>
Clients that choose not to include WM_DELETE_WINDOW in the WM_PROTOCOLS
property may be disconnected from the server
if the user asks for one of the client's top-level windows to be deleted.

<H3><A NAME="s-4.2.9">4.2.9.</A> Redirecting Requests</H3>
Normal clients can use the redirection mechanism just as window managers do
by selecting for 
<B>SubstructureRedirect</B>
events on a parent window or 
<B>ResizeRedirect</B>
events on a window itself.
However, at most,
one client per window can select for these events,
and a convention is needed to avoid clashes.
<P ALIGN=center> Convention
<BLOCKQUOTE>
<P>Clients (including window managers) should select for 
<B>SubstructureRedirect</B>
and
<B>ResizeRedirect</B>
events only on windows that they own.
</BLOCKQUOTE>
<P>
In particular, 
clients that need to take some special action if they are resized can select
for 
<B>ResizeRedirect</B>
events on their top-level windows.
They will receive a
<B>ResizeRequest</B>
event if the window manager resizes their window,
and the resize will not actually take place.
Clients are free to make what use they like of the information
that the window manager wants to change their size,
but they must configure the window to the width and height specified 
in the event in a timely fashion.
To ensure that the resize will actually happen at this stage
instead of being intercepted and executed by the window manager
(and thus restarting the process),
the client needs temporarily to set override-redirect on the window.
<P ALIGN=center> Convention
<BLOCKQUOTE>
<P>Clients receiving 
<B>ResizeRequest</B>
events must respond by doing the following:
<UL>
<LI> Setting override-redirect on the window specified in the event
<LI> Configuring the window specified in the event 
to the width and height specified in the event as soon as possible 
and before making any other geometry requests
<LI> Clearing override-redirect on the window specified in the event
</BLOCKQUOTE>
</UL>
If a window manager detects that a client is not obeying this convention,
it is free to take whatever measures it deems appropriate to deal with
the client.

<H2><A NAME="s-4.3">4.3.</A> Communication with the Window Manager by Means of Selections</H2>
For each screen they manage, window managers will acquire ownership of a
selection named WM_S<I>n</I>, where <I>n</I> is the screen number, as
described in <A HREF="sec-1.html#s-1.2.6">section 1.2.6</A>.  Window managers should comply with the
conventions for &quot;Manager Selections&quot; described in <A HREF="sec-2.html#s-2.8">section 2.8</A>.  The
intent is for clients to be able to request a variety of information or
services by issuing conversion requests on this selection.  Window managers
should support conversion of the following target on their manager
selection:
<P>
<TABLE>
<TR><TH COLSPAN=3><HR>
<TR><TH ALIGN=left>Atom	<TH ALIGN=left>Type	<TH ALIGN=left>Data Received
<TR><TH COLSPAN=3><HR>
<TR><TD>VERSION	<TD>INTEGER	<TD>Two integers, which are the major and minor release numbers (respectively) of the ICCCM with which the window manager complies.  For this version of the ICCCM, the numbers are 2 and 0.<A HREF="footnotes.html#f-15"><SUP>15</SUP></A>

<TR><TH COLSPAN=3><HR>
</TABLE>

<H2><A NAME="s-4.4">4.4.</A> Summary of Window Manager Property Types</H2>
The window manager properties are summarized in the following table
(see also <A HREF="/gui/x/xlib/ICC/client-to-window-manager/">section 14.1 of <I>Xlib - C Language X Interface</I></A>).
<TABLE>
<TR><TH COLSPAN=4><HR>
<TR><TH ALIGN=left>Name	<TH ALIGN=left>Type	<TH ALIGN=left>Format	<TH ALIGN=left>See Section
<TR><TH COLSPAN=4><HR>
<TR><TD>WM_CLASS	<TD>STRING	<TD>8	<TD><A HREF="sec-4.html#s-4.1.2.5">4.1.2.5</A>
<TR><TD>WM_CLIENT_MACHINE	<TD>TEXT	<TD>&	<TD><A HREF="sec-4.html#s-4.1.2.9">4.1.2.9</A>
<TR><TD>WM_COLORMAP_WINDOWS	<TD>WINDOW	<TD>32	<TD><A HREF="sec-4.html#s-4.1.2.8">4.1.2.8</A>
<TR><TD>WM_HINTS	<TD>WM_HINTS	<TD>32	<TD><A HREF="sec-4.html#s-4.1.2.4">4.1.2.4</A>
<TR><TD>WM_ICON_NAME	<TD>TEXT	<TD>	<TD><A HREF="sec-4.html#s-4.1.2.2">4.1.2.2</A>
<TR><TD>WM_ICON_SIZE	<TD>WM_ICON_SIZE	<TD>32	<TD><A HREF="sec-4.html#s-4.1.3.2">4.1.3.2</A>
<TR><TD>WM_NAME	<TD>TEXT	<TD>	<TD><A HREF="sec-4.html#s-4.1.2.1">4.1.2.1</A>
<TR><TD>WM_NORMAL_HINTS	<TD>WM_SIZE_HINTS	<TD>32	<TD><A HREF="sec-4.html#s-4.1.2.3">4.1.2.3</A>
<TR><TD>WM_PROTOCOLS	<TD>ATOM	<TD>32	<TD><A HREF="sec-4.html#s-4.1.2.7">4.1.2.7</A>
<TR><TD>WM_STATE	<TD>WM_STATE	<TD>32	<TD><A HREF="sec-4.html#s-4.1.3.1">4.1.3.1</A>
<TR><TD>WM_TRANSIENT_FOR	<TD>WINDOW	<TD>32	<TD><A HREF="sec-4.html#s-4.1.2.6">4.1.2.6</A>
<TR><TH COLSPAN=4><HR>
</TABLE>


<HR>
<A HREF="sec-3.html"><IMG SRC="/images/left.gif" WIDTH=31 HEIGHT=31 ALT="<"></A><A HREF="./"><IMG SRC="/images/up.gif" WIDTH=31 HEIGHT=31 ALT="^"></A><A HREF="sec-5.html"><IMG SRC="/images/right.gif" WIDTH=31 HEIGHT=31 ALT=">"></A>
<P><ADDRESS><A HREF="http://tronche.com/">Christophe Tronche</A>, <A HREF="mailto:ch.tronche@computer.org">ch.tronche@computer.org</A></ADDRESS>
</BODY>
</HTML>
