<HTML>
<HEAD>
<TITLE>ICCCM - Peer-to-Peer Communication by Means of Selections</TITLE>
</HEAD>

<BODY>
<H1><A NAME="s-2">2.</A> Peer-to-Peer Communication by Means of Selections</H1>
Selections are the primary mechanism that X Version 11 defines 
for the exchange of information between clients,
for example, by cutting and pasting between windows.
Note that there can be an arbitrary number of selections
(each named by an atom) and that they are global to the server.
<A HREF="sec-2.html#s-2.6">Section 2.6</A> discusses the choice of an atom.
Each selection is owned by a client and is attached to a window.
<P>
Selections communicate between an owner and a requestor.
The owner has the data representing the value of its selection,
and the requestor receives it.
A requestor wishing to obtain the value of a selection provides the following:
<UL>
<LI> The name of the selection
<LI> The name of a property
<LI> A window
<LI> The atom representing the data type required
<LI> Optionally, some parameters for the request
</UL>
If the selection is currently owned,
the owner receives an event and is expected to do the following:
<UL>
<LI> Convert the contents of the selection to the requested data type
<LI> Place this data in the named property on the named window
<LI> Send the requestor an event to let it know the property is available
</UL>
Clients are strongly encouraged to use this mechanism.
In particular,
displaying text in a permanent window without providing the ability 
to select and convert it into a string is definitely considered antisocial.
<P>
Note that all data transferred between an owner and a requestor must usually 
go by means of the server in an X Version 11 environment.
A client cannot assume that another client can open the same files
or even communicate directly.
The other client may be talking to the server by means of 
a completely different networking mechanism (for example,  one client might
be DECnet and the other TCP/IP).
Thus, passing indirect references to data 
(such as file names,  host names and port numbers, and so on) 
is permitted only if both clients specifically agree.

<H2><A NAME="s-2.1">2.1.</A> Acquiring Selection Ownership</H2>
A client wishing to acquire ownership of a particular selection
should call 
<B>SetSelectionOwner,</B>
which is defined as follows:
<P>
<TABLE>
<CAPTION><B>SetSelectionOwner</B></CAPTION>
<TR><TD ALIGN=right><I>selection</I> :	<TD> ATOM
<TR><TD ALIGN=right><I>owner</I> :	<TD> WINDOW or
<B>None</B>
<TR><TD ALIGN=right><I>time</I> :	<TD> TIMESTAMP or
<B>CurrentTime</B>
</TABLE>
<P>
The client should set the specified selection to the atom that represents 
the selection,
set the specified owner to some window that the client created,
and set the specified time to some time between the current last-change time 
of the selection concerned and the current server time.
This time value usually will be obtained from the timestamp of the event 
that triggers the acquisition of the selection.
Clients should not set the time
value to 
<B>CurrentTime ,</B>
because if they do so, they have no way of finding
when they gained ownership of the selection.
Clients must use a window they created so that requestors
can route events to the owner of the selection.<A HREF="footnotes.html#f-2"><SUP>2</SUP></A>

<P ALIGN=center> Convention
<BLOCKQUOTE>
<P>Clients attempting to acquire a selection must set the time value of the 
<B>SetSelectionOwner </B>
request to the timestamp of the event triggering the acquisition attempt, 
not to 
<B>CurrentTime .</B>
A zero-length append to a property is a way to obtain a timestamp for
this purpose;
the timestamp is in the corresponding 
<B>PropertyNotify</B>
event.
</BLOCKQUOTE>
<P>
If the time in the 
<B>SetSelectionOwner </B>
request is in the future relative to the server's current time 
or is in the past relative to the last time the specified selection 
changed hands, the 
<B>SetSelectionOwner</B>
request appears to the client to succeed,
but ownership is not actually transferred.
<P>
Because clients cannot name other clients directly,
the specified owner window is used to refer to the owning client
in the replies to 
<B>GetSelectionOwner ,</B>
in 
<B>SelectionRequest </B>
and
<B>SelectionClear</B>
events, and possibly as a place to put properties describing the selection
in question.
To discover the owner of a particular selection,
a client should invoke
<B>GetSelectionOwner ,</B>
which is defined as follows:
<P>
<TABLE>
<CAPTION><B>GetSelectionOwner</B></CAPTION>
<TR><TD ALIGN=right><I>selection</I> :	<TD> ATOM
<TR><TD ALIGN=right>->
<TR><TD ALIGN=right>owner :	<TD> WINDOW or
<B>None</B>
</TABLE>
<P ALIGN=center> Convention
<BLOCKQUOTE>
<P>Clients are expected to provide some visible confirmation
of selection ownership.
To make this feedback reliable,
a client must perform a sequence like the following:
<PRE><CODE>
SetSelectionOwner(selection=PRIMARY, owner=Window, time=timestamp)
owner = GetSelectionOwner(selection=PRIMARY)
if (owner != Window) Failure
</CODE></PRE>
</BLOCKQUOTE>
<P>
If the 
<B>SetSelectionOwner</B>
request succeeds (not merely appears to succeed),
the client that issues it is recorded by the server as being the owner 
of the selection for the time period starting at the specified time.

<H2><A NAME="s-2.2">2.2.</A> Responsibilities of the Selection Owner</H2>
When a requestor wants the value of a selection,
the owner receives a 
<B>SelectionRequest</B>
event, which is defined as follows:
<P>
<TABLE>
<CAPTION><B>SelectionRequest</B></CAPTION>
<TR><TD ALIGN=right><I>owner</I> :	<TD> WINDOW
<TR><TD ALIGN=right><I>selection</I> :	<TD> ATOM
<TR><TD ALIGN=right><I>target</I> :	<TD> ATOM
<TR><TD ALIGN=right><I>property</I> :	<TD> ATOM or
<B>None</B>
<TR><TD ALIGN=right><I>requestor</I> :	<TD> WINDOW
<TR><TD ALIGN=right><I>time</I> :	<TD> TIMESTAMP or
<B>CurrentTime</B>
</TABLE>
<P>
The specified owner and selection will be the values that were specified in
the
<B>SetSelectionOwner </B>
request.
The owner should compare the timestamp with the period 
it has owned the selection and, if the time is outside,
refuse the 
<B>SelectionRequest </B>
by sending the requestor window a 
<B>SelectionNotify </B>
event with the property set to 
<B>None </B>
(by means of a
<B>SendEvent</B>
request with an empty event mask).
<P>
More advanced selection owners are free to maintain a history
of the value of the selection and to respond to requests for the
value of the selection during periods they owned it
even though they do not own it now.
<P>
If the specified property is 
<B>None ,</B>
the requestor is an obsolete client.
Owners are encouraged to support these clients by using the specified target
atom as the property name to be used for the reply.
<P>
Otherwise,
the owner should use the target to decide the form into which the selection
should be converted.
Some targets may be defined such that requestors can pass parameters
along with the request.  The owner will find these parameters in the
property named in the selection request.  The type, format, and
contents of this property are dependent upon the definition of the
target.  If the target is not defined to have parameters, the owner
should ignore the property if it is present.
If the selection cannot be converted
into a form based on the target (and parameters, if any),
the owner should refuse the 
<B>SelectionRequest</B>
as previously described.
<P>
If the specified property is not 
<B>None ,</B>
the owner should place the data resulting from converting the selection 
into the specified property on the requestor window
and should set the property's type to some appropriate value,
which need not be the same as the specified target.
<P ALIGN=center> Convention
<BLOCKQUOTE>
<P>All properties used to reply to 
<B>SelectionRequest</B>
events must be placed on the requestor window.
</BLOCKQUOTE>
<P>
In either case, 
if the data comprising the selection cannot be stored on the requestor window 
(for example, because the server cannot provide sufficient memory),
the owner must refuse the 
<B>SelectionRequest ,</B>
as previously described.
See also <A HREF="sec-2.html#s-2.5">section 2.5</A>.
<P>
If the property is successfully stored,
the owner should acknowledge the successful conversion
by sending the requestor window a 
<B>SelectionNotify </B>
event (by means of a
<B>SendEvent</B>
request with an empty mask).
<B>SelectionNotify</B>
is defined as follows:
<P>
<TABLE>
<CAPTION><B>SelectionNotify</B></CAPTION>
<TR><TD ALIGN=right><I>requestor</I> :	<TD> WINDOW
<TR><TD ALIGN=right><I>selection</I>, <I>target</I> :	<TD> ATOM
<TR><TD ALIGN=right><I>property</I> :	<TD> ATOM or
<B>None</B>
<TR><TD ALIGN=right><I>time</I> :	<TD> TIMESTAMP or
<B>CurrentTime</B>
</TABLE>
<P>
The owner should set the specified selection, target, time, 
and property arguments to the values received in the 
<B>SelectionRequest </B>
event.
(Note that setting the property argument to 
<B>None </B>
indicates that the conversion requested could not be made.)
<P ALIGN=center> Convention
<BLOCKQUOTE>
<P>The selection, target, time, and property arguments in the 
<B>SelectionNotify </B>
event should be set to the values received in the 
<B>SelectionRequest </B>
event.
</BLOCKQUOTE>
<P>
If the owner receives more than one
<B>SelectionRequest</B>
event with the same requestor, selection, target, and timestamp, it must
respond to them in the same order in which they were received.
<P ALIGN=center> Rationale
<BLOCKQUOTE>
<P>It is possible for a requestor to have multiple outstanding requests that
use the same requestor window, selection, target, and timestamp, and that
differ only in the property.  If this occurs, and one of the conversion
requests fails, the resulting
<B>SelectionNotify</B>
event will have its property argument set to 
<B>None .</B>
This may make it impossible for the requestor to determine which conversion
request had failed, unless the requests are responded to in order.
</BLOCKQUOTE>
<P>
The data stored in the property must eventually be deleted.
A convention is needed to assign the responsibility for doing so.
<P ALIGN=center> Convention
<BLOCKQUOTE>
<P>Selection requestors are responsible for deleting properties whose
names they receive in 
<B>SelectionNotify </B>
events (see <A HREF="sec-2.html#s-2.4">section 2.4</A>) or in properties with type MULTIPLE.
</BLOCKQUOTE>
<P>
A selection owner will often need confirmation that the data comprising the
selection has actually been transferred.
(For example, 
if the operation has side effects on the owner's internal data structures, 
these should not take place until the requestor has indicated 
that it has successfully received the data.)
Owners should express interest in 
<B>PropertyNotify </B>
events for the specified requestor window 
and wait until the property in the 
<B>SelectionNotify </B>
event has been deleted before assuming that the selection data has been
transferred.  For the MULTIPLE request, if the different conversions require
separate confirmation, the selection owner can also watch for the deletion
of the individual properties named in the property in the
<B>SelectionNotify</B>
event.
<P>
When some other client acquires a selection,
the previous owner receives a 
<B>SelectionClear </B>
event, which is defined as follows:
<P>
<TABLE>
<CAPTION><B>SelectionClear</B></CAPTION>
<TR><TD ALIGN=right><I>owner</I> :	<TD> WINDOW
<TR><TD ALIGN=right><I>selection</I> :	<TD> ATOM
<TR><TD ALIGN=right><I>time</I> :	<TD> TIMESTAMP
</TABLE>
<P>
The timestamp argument is the time at which the ownership changed hands,
and the owner argument is the window the previous owner specified in its
<B>SetSelectionOwner </B>
request.
<P>
If an owner loses ownership while it has a transfer in progress (that is,
before it receives notification that the requestor has received all the data),
it must continue to service the ongoing transfer until it is complete.
<P>
If the selection value completely changes, but the owner happens
to be the same client (for example, selecting a totally different
piece of text in the same <B>xterm</B> as before), then the client should
reacquire the selection ownership as if it were not the owner,
providing a new timestamp. If the selection value is modified, but
can still reasonably be viewed as the same selected object,<A HREF="footnotes.html#f-3"><SUP>3</SUP></A>
 the
owner should take no action.

<H2><A NAME="s-2.3">2.3.</A> Giving Up Selection Ownership</H2>
Clients may either give up selection ownership voluntarily 
or lose it forcibly as the result of some other client's actions.

<H3><A NAME="s-2.3.1">2.3.1.</A> Voluntarily Giving Up Selection Ownership</H3>
To relinquish ownership of a selection voluntarily,
a client should execute a 
<B>SetSelectionOwner</B>
request for that selection atom, with owner specified as 
<B>None</B>
and the time specified as the timestamp that was used to acquire the selection.
<P>
Alternatively,
the client may destroy the window used as the owner value of the 
<B>SetSelectionOwner</B>
request, or the client may terminate.
In both cases,
the ownership of the selection involved will revert to 
<B>None .</B>

<H3><A NAME="s-2.3.2">2.3.2.</A> Forcibly Giving Up Selection Ownership</H3>
If a client gives up ownership of a selection
or if some other client executes a 
<B>SetSelectionOwner </B>
for it and thus reassigns it forcibly,
the previous owner will receive a 
<B>SelectionClear </B>
event. For the definition of a 
<B>SelectionClear</B>
event, see <A HREF="sec-2.html#s-2.2">section 2.2</A>.
<P>
The timestamp is the time the selection changed hands.
The specified owner is the window that was specified by the current owner 
in its 
<B>SetSelectionOwner</B>
request.

<H2><A NAME="s-2.4">2.4.</A> Requesting a Selection</H2>
A client that wishes to obtain the value of a selection in a particular
form (the requestor) issues a 
<B>ConvertSelection </B>
request, which is defined as follows:
<P>
<TABLE>
<CAPTION><B>ConvertSelection</B></CAPTION>
<TR><TD ALIGN=right><I>selection</I>, <I>target</I> :	<TD> ATOM
<TR><TD ALIGN=right><I>property</I> :	<TD> ATOM or
<B>None</B>
<TR><TD ALIGN=right><I>requestor</I> :	<TD> WINDOW
<TR><TD ALIGN=right><I>time</I> :	<TD> TIMESTAMP or
<B>CurrentTime</B>
</TABLE>
<P>
The selection argument specifies the particular selection involved,
and the target argument specifies the required form of the information.
For information about the choice of suitable atoms to use,
see <A HREF="sec-2.html#s-2.6">section 2.6</A>.
The requestor should set the requestor argument to a window that it created;
the owner will place the reply property there.
The requestor should set the time argument to the timestamp on the event 
that triggered the request for the selection value.
Note that clients should not specify 
<B>CurrentTime .</B>
<P ALIGN=center> Convention
<BLOCKQUOTE>
<P>Clients should not use 
<B>CurrentTime </B>
for the time argument of a 
<B>ConvertSelection</B>
request.
Instead, they should use the timestamp of the event that caused the request 
to be made.
</BLOCKQUOTE>
<P>
The requestor should set the property argument to the name of a property 
that the owner can use to report the value of the selection.
Requestors should ensure that the named property does not exist
on the window before issuing the
<B>ConvertSelection</B>
request.<A HREF="footnotes.html#f-4"><SUP>4</SUP></A>
 The exception to this rule is when the requestor intends to pass
parameters with the request; see below.
<P ALIGN=center> Rationale
<BLOCKQUOTE>
<P>It is necessary for requestors to delete the property before issuing the
request so that the target can later be extended to take parameters without
introducing an incompatibility.  Also note that the requestor of a selection
need not know the client that owns the selection nor the window on which
the selection was acquired.
</BLOCKQUOTE>
<P>
Some targets may be defined such that requestors can pass parameters
along with the request.  If the requestor wishes to provide parameters
to a request, they should be placed in the specified property on the
requestor window before the requestor issues the
<B>ConvertSelection</B>
request, and this property should be named in the request.
<P>
Some targets may be defined so that parameters are optional.  If no
parameters are to be supplied with the request of such a target, the
requestor must ensure that the property does not exist before issuing
the
<B>ConvertSelection</B>
request.
<P>
The protocol allows the property field to be set to 
<B>None ,</B>
in which case the owner is supposed to choose a property name.
However, it is difficult for the owner to make this choice safely.
<OL>
<P ALIGN=center> Conventions<P>
<LI> Requestors should not use 
<B>None</B>
for the property argument of a
<B>ConvertSelection</B>
request.
<LI> Owners receiving 
<B>ConvertSelection </B>
requests with a property argument of
<B>None</B>
are talking to an obsolete client.
They should choose the target atom as the property name to be used 
for the reply.
</OL>
<P>
The result of the 
<B>ConvertSelection</B>
request is that a 
<B>SelectionNotify</B>
event will be received.
For the definition of a
<B>SelectionNotify</B>
event, see <A HREF="sec-2.html#s-2.2">section 2.2</A>.
<P>
The requestor, selection, time, and target arguments will be the same
as those on the 
<B>ConvertSelection </B>
request.
<P>
If the property argument is 
<B>None ,</B>
the conversion has been refused.
This can mean either that there is no owner for the selection, 
that the owner does not support the conversion implied by the target,
or that the server did not have sufficient space to accommodate the data.
<P>
If the property argument is not 
<B>None ,</B>
then that property will exist on the requestor window.
The value of the selection can be retrieved from this
property by using the 
<B>GetProperty</B>
request, which is defined as follows:
<P>
<TABLE>
<CAPTION><B>GetProperty</B></CAPTION>
<TR><TD ALIGN=right><I>window</I> :	<TD> WINDOW
<TR><TD ALIGN=right><I>property</I> :	<TD> ATOM
<TR><TD ALIGN=right><I>type</I> :	<TD> ATOM or
<B>AnyPropertyType</B>
<TR><TD ALIGN=right><I>long-offset</I>, <I>long-length</I> :	<TD> CARD32
<TR><TD ALIGN=right><I>delete</I> :	<TD> BOOL
<TR><TD ALIGN=right>->
<TR><TD ALIGN=right>type :	<TD> ATOM or
<B>None</B>
<TR><TD ALIGN=right>format :	<TD> {0, 8, 16, 32}
<TR><TD ALIGN=right>bytes-after :	<TD> CARD32
<TR><TD ALIGN=right>value :	<TD> LISTofINT8 or LISTofINT16 or LISTofINT32
</TABLE>
<P>
When using 
<B>GetProperty </B>
to retrieve the value of a selection,  
the property argument should be set to the corresponding value in the 
<B>SelectionNotify</B>
event.
Because the requestor has no way of knowing beforehand what type 
the selection owner will use,
the type argument should be set to 
<B>AnyPropertyType .</B>
Several 
<B>GetProperty </B>
requests may be needed to retrieve all the data in the selection;
each should set the long-offset argument to the amount of data received so far,
and the size argument to some reasonable buffer size (see <A HREF="sec-2.html#s-2.5">section 2.5</A>).
If the returned value of bytes-after is zero,
the whole property has been transferred.
<P>
Once all the data in the selection has been retrieved
(which may require getting the values of several properties &emdash;
see <A HREF="sec-2.html#s-2.7">section 2.7</A>),
the requestor should delete the property in the 
<B>SelectionNotify</B>
request by using a 
<B>GetProperty</B>
request with the delete argument set to
<B>True .</B>
As previously discussed,
the owner has no way of knowing when the data has been
transferred to the requestor unless the property is removed.
<P ALIGN=center> Convention
<BLOCKQUOTE>
<P>The requestor must delete the property named in the 
<B>SelectionNotify</B>
once all the data has been retrieved.
The requestor should invoke either 
<B>DeleteProperty </B>
or
<B>GetProperty (delete==True)</B>
after it has successfully retrieved all the data in the selection.
For further information,
see <A HREF="sec-2.html#s-2.5">section 2.5</A>.
</BLOCKQUOTE>

<H2><A NAME="s-2.5">2.5.</A> Large Data Transfers</H2>
Selections can get large, which poses two problems:
<UL>
<LI> Transferring large amounts of data to the server is expensive.
<LI> All servers will have limits on the amount of data that can be stored
in properties.
Exceeding this limit will result in an 
<B>Alloc</B>
error on the 
<B>ChangeProperty </B>
request that the selection owner uses to store the data.
</UL>
The problem of limited server resources is addressed by the following
conventions:
<OL>
<P ALIGN=center> Conventions<P>
<LI> Selection owners should transfer the data describing a large selection
(relative to the maximum-request-size they received 
in the connection handshake) using the INCR property mechanism 
(see <A HREF="sec-2.html#s-2.7.2">section 2.7.2</A>).
<LI> Any client using 
<B>SetSelectionOwner</B>
to acquire selection ownership should arrange to process 
<B>Alloc</B>
errors in property change requests.
For clients using Xlib,
this involves using the
<B><A HREF="/gui/x/xlib/event-handling/protocol-errors/XSetErrorHandler.html">XSetErrorHandler()</A></B>
function to override the default handler.
<LI> A selection owner must confirm that no 
<B>Alloc</B>
error occurred while storing the properties for a selection 
before replying with a confirming 
<B>SelectionNotify</B>
event.
<LI> When storing large amounts of data (relative to maximum-request-size),
clients should use a sequence of 
<B>ChangeProperty (mode==Append)</B>
requests for reasonable quantities of data.
This avoids locking servers up and limits the waste of data an
<B>Alloc </B>
error would cause.
<LI> If an 
<B>Alloc </B>
error occurs during the storing of the selection data,
all properties stored for this selection should be deleted
and the 
<B>ConvertSelection</B>
request should be refused (see <A HREF="sec-2.html#s-2.2">section 2.2</A>).
<LI> To avoid locking servers up for inordinate lengths of time,
requestors retrieving large quantities of data from a property
should perform a series of 
<B>GetProperty </B>
requests, each asking for a reasonable amount of data.
</OL>
<P ALIGN=center>Advice to Implementors
<BLOCKQUOTE>
<P>Single-threaded servers should take care to avoid locking up during large
data transfers.
</BLOCKQUOTE>

<H2><A NAME="s-2.6">2.6.</A> Use of Selection Atoms</H2>
Defining a new atom consumes resources in the server
that are not released until the server reinitializes.
Thus, reducing the need for newly minted atoms is an important goal
for the use of the selection atoms.

<H3><A NAME="s-2.6.1">2.6.1.</A> Selection Atoms</H3>
There can be an arbitrary number of selections, each named by an atom.
To conform with the inter-client conventions, however,
clients need deal with only these three selections:
<UL>
<LI> PRIMARY
<LI> SECONDARY
<LI> CLIPBOARD
</UL>
Other selections may be used freely for private communication among
related groups of clients.

<H4><A NAME="s-2.6.1.1">2.6.1.1.</A> The PRIMARY Selection</H4>
The selection named by the atom PRIMARY is used for all commands
that take only a single argument and is the principal means of communication 
between clients that use the selection mechanism.

<H4><A NAME="s-2.6.1.2">2.6.1.2.</A> The SECONDARY Selection</H4>
The selection named by the atom SECONDARY is used:
<UL>
<LI> As the second argument to commands taking two arguments 
(for example, &quot;exchange primary and secondary selections&quot;)
<LI> As a means of obtaining data when there is a primary selection
and the user does not want to disturb it

</UL>
<H4><A NAME="s-2.6.1.3">2.6.1.3.</A> The CLIPBOARD Selection</H4>
The selection named by the atom CLIPBOARD is used to hold data
that is being transferred between clients, 
that is, data that usually is being cut or copied, and then pasted.
Whenever a client wants to transfer data to the clipboard:
<UL>
<LI> It should assert ownership of the CLIPBOARD.
<LI> If it succeeds in acquiring ownership,
it should be prepared to respond to a request for the contents of the CLIPBOARD
in the usual way (retaining the data to be able to return it).
The request may be generated by the clipboard client described below.
<LI> If it fails to acquire ownership,
a cutting client should not actually perform the cut or provide feedback 
that would suggest that it has actually transferred data to the clipboard.
</UL>
The owner should repeat this process whenever the data to be transferred
would change.
<P>
Clients wanting to paste data from the clipboard should request 
the contents of the CLIPBOARD selection in the usual way.
<P>
Except while a client is actually deleting or copying data,
the owner of the CLIPBOARD selection may be a single, special client
implemented for the purpose.
This client maintains the content of the clipboard up-to-date
and responds to requests for data from the clipboard as follows:
<UL>
<LI> It should assert ownership of the CLIPBOARD selection
and reassert it any time the clipboard data changes.
<LI> If it loses the selection (because another client has some new data 
for the clipboard),
it should:
<UL>
<LI> Obtain the contents of the selection from the new owner by using the timestamp
in the 
<B>SelectionClear</B>
event.
<LI> Attempt to reassert ownership of the CLIPBOARD selection 
by using the same timestamp.
<LI> Restart the process using a newly acquired timestamp if this attempt fails.
This timestamp should be obtained by asking the current owner of the
CLIPBOARD selection to convert it to a TIMESTAMP.
If this conversion is refused or if the same timestamp is received twice,
the clipboard client should acquire a fresh timestamp in the
usual way (for example by a zero-length append to a property).
</UL>
<LI> It should respond to requests for the CLIPBOARD contents in the usual way.
</UL>
A special CLIPBOARD client is not necessary.
The protocol used by the cutting client and the pasting client
is the same whether the CLIPBOARD client is running or not.
The reasons for running the special client include:
<UL>
<LI> Stability - If the cutting client were to crash or terminate,
the clipboard value would still be available.
<LI> Feedback - The clipboard client can display the contents of the clipboard.
<LI> Simplicity - A client deleting data does not have to retain it for so long,
thus reducing the chance of race conditions causing problems.
</UL>
The reasons not to run the clipboard client include:
<UL>
<LI> Performance - Data is only transferred if it is actually required 
(that is, when some client actually wants the data).
<LI> Flexibility - The clipboard data may be available as more than one target.

</UL>
<H3><A NAME="s-2.6.2">2.6.2.</A> Target Atoms</H3>
The atom that a requestor supplies as the target of a 
<B>ConvertSelection</B>
request determines the form of the data supplied.
The set of such atoms is extensible, 
but a generally accepted base set of target atoms is needed.
As a starting point for this, 
the following table contains those that have been suggested so far.
<TABLE>
<TR><TH COLSPAN=3><HR>
<TR><TH ALIGN=left>Atom	<TH ALIGN=left>Type 	<TH ALIGN=left>Data Received
<TR><TH COLSPAN=3><HR>
<TR><TD>ADOBE_PORTABLE_DOCUMENT_FORMAT	<TD>STRING	<TD>[1]
<TR><TD>APPLE_PICT	<TD>APPLE_PICT	<TD>[2]
<TR><TD>BACKGROUND	<TD>PIXEL	<TD>A list of pixel values
<TR><TD>BITMAP	<TD>BITMAP	<TD>A list of bitmap IDs
<TR><TD>CHARACTER_POSITION	<TD>SPAN	<TD>The start and end of the selection in bytes
<TR><TD>CLASS	<TD>TEXT	<TD>(see <A HREF="sec-4.html#s-4.1.2.5">section 4.1.2.5</A>)
<TR><TD>CLIENT_WINDOW	<TD>WINDOW	<TD>Any top-level window owned by the selection owner
<TR><TD>COLORMAP	<TD>COLORMAP	<TD>A list of colormap IDs
<TR><TD>COLUMN_NUMBER	<TD>SPAN	<TD>The start and end column numbers
<TR><TD>COMPOUND_TEXT	<TD>COMPOUND_TEXT	<TD>Compound Text
<TR><TD>DELETE	<TD>NULL	<TD>(see <A HREF="sec-2.html#s-2.6.3.1">section 2.6.3.1</A>)
<TR><TD>DRAWABLE	<TD>DRAWABLE	<TD>A list of drawable IDs
<TR><TD>ENCAPSULATED_POSTSCRIPT	<TD>STRING	<TD>[3], Appendix H<A HREF="footnotes.html#f-5"><SUP>5</SUP></A>
<TR><TD>ENCAPSULATED_POSTSCRIPT_INTERCHANGE	<TD>STRING	<TD>[3], Appendix H
<TR><TD>FILE_NAME	<TD>TEXT	<TD>The full path name of a file
<TR><TD>FOREGROUND	<TD>PIXEL	<TD>A list of pixel values
<TR><TD>HOST_NAME	<TD>TEXT	<TD>(see <A HREF="sec-4.html#s-4.1.2.9">section 4.1.2.9</A>)
<TR><TD>INSERT_PROPERTY	<TD>NULL	<TD>(see <A HREF="sec-2.html#s-2.6.3.3">section 2.6.3.3</A>)
<TR><TD>INSERT_SELECTION	<TD>NULL	<TD>(see <A HREF="sec-2.html#s-2.6.3.2">section 2.6.3.2</A>)
<TR><TD>LENGTH	<TD>INTEGER	<TD>The number of bytes in the selection<A HREF="footnotes.html#f-6"><SUP>6</SUP></A>
<TR><TD>LINE_NUMBER	<TD>SPAN	<TD>The start and end line numbers
<TR><TD>LIST_LENGTH	<TD>INTEGER	<TD>The number of disjoint parts of the selection
<TR><TD>MODULE	<TD>TEXT	<TD>The name of the selected procedure
<TR><TD>MULTIPLE	<TD>ATOM_PAIR	<TD>(see the discussion that follows)
<TR><TD>NAME	<TD>TEXT	<TD>(see <A HREF="sec-4.html#s-4.1.2.1">section 4.1.2.1</A>)
<TR><TD>ODIF	<TD>TEXT	<TD>ISO Office Document Interchange Format
<TR><TD>OWNER_OS	<TD>TEXT	<TD>The operating system of the owner client
<TR><TD>PIXMAP	<TD>PIXMAP<A HREF="footnotes.html#f-7"><SUP>7</SUP></A>	<TD>A list of pixmap IDs
<TR><TD>POSTSCRIPT	<TD>STRING	<TD>[3]
<TR><TD>PROCEDURE	<TD>TEXT	<TD>The name of the selected procedure
<TR><TD>PROCESS	<TD>INTEGER, TEXT	<TD>The process ID of the owner
<TR><TD>STRING	<TD>STRING	<TD>ISO Latin-1 (+TAB+NEWLINE) text
<TR><TD>TARGETS	<TD>ATOM	<TD>A list of valid target atoms
<TR><TD>TASK	<TD>INTEGER, TEXT	<TD>The task ID of the owner
<TR><TD>TEXT	<TD>TEXT	<TD>The text in the owner's choice of encoding
<TR><TD>TIMESTAMP	<TD>INTEGER	<TD>The timestamp used to acquire the selection
<TR><TD>USER	<TD>TEXT	<TD>The name of the user running the owner
<TR><TH COLSPAN=3><HR>
</TABLE>

<P>
References:
<DL>
<DT> 1<DD>
Adobe Systems, Incorporated.
<I>
Portable Document Format Reference Manual.
</I>
Addison-Wesley, ISBN 0-201-62628-4.
<DT> 2<DD>
Apple Computer, Incorporated.
<I>
Inside Macintosh, Volume V.
</I>
Chapter 4, &quot;Color QuickDraw,&quot; Color Picture Format.
ISBN 0-201-17719-6.
<DT> 3<DD>
Adobe Systems, Incorporated.
<I>
PostScript Language Reference Manual.
</I>
Addison-Wesley, ISBN 0-201-18127-4.
</DL>
It is expected that this table will grow over time.
<P>
Selection owners are required to support the following targets.
All other targets are optional.
<UL>
<LI> TARGETS - The owner should return a list of atoms that represent
the targets for which an attempt to convert the current selection
will succeed (barring unforseeable problems such as 
<B>Alloc </B>
errors).
This list should include all the required atoms.
<LI> MULTIPLE - The MULTIPLE target atom is valid only when a property 
is specified on the 
<B>ConvertSelection </B>
request.
If the property argument in the 
<B>SelectionRequest </B>
event is 
<B>None </B>
and the target is MULTIPLE, 
it should be refused.
<P>
When a selection owner receives a 
<B>SelectionRequest (target==MULTIPLE)</B>
request,
the contents of the property named in the request will be a list of atom pairs:
the first atom naming a target and the second naming a property 
<B>( None </B>
is not valid here).
The effect should be as if the owner had received a sequence of
<B>SelectionRequest </B>
events (one for each atom pair) except that:
<UL>
<LI> The owner should reply with a 
<B>SelectionNotify </B>
only when all the requested conversions have been performed.
<LI> If the owner fails to convert the target named by an atom 
in the MULTIPLE property,
it should replace that atom in the property with
<B>None .</B>
</UL>
</UL>
<P ALIGN=center> Convention
<BLOCKQUOTE>
<P>The entries in a MULTIPLE property must be processed in the order
they appear in the property.
For further information,
see <A HREF="sec-2.html#s-2.6.3">section 2.6.3</A>.
</BLOCKQUOTE>
<P>
The requestor should delete each individual property when it has
copied the data from that conversion, and the property specified in the
MULTIPLE request when it has copied all the data.
<P>
The requests are otherwise to be processed independently, and they
should succeed or fail independently.  The MULTIPLE target is an
optimization that reduces the amount of protocol traffic between the
owner and the requestor; it is not a transaction mechanism.  For
example, a client may issue a MULTIPLE request with two targets: a data
target and the DELETE target.  The DELETE target will still be processed
even if the conversion of the data target fails.
<UL>
<LI> TIMESTAMP - To avoid some race conditions,
it is important that requestors be able to discover the timestamp 
the owner used to acquire ownership.
Until and unless the protocol is changed so that a
<B>GetSelectionOwner</B>
request returns the timestamp used to acquire ownership,
selection owners must support conversion to TIMESTAMP,
returning the timestamp they used to obtain the selection.

</UL>
<H3><A NAME="s-2.6.3">2.6.3.</A> Selection Targets with Side Effects</H3>
Some targets (for example, DELETE) have side effects.
To render these targets unambiguous,
the entries in a MULTIPLE property must be processed in the order 
that they appear in the property.
<P>
In general,
targets with side effects will return no information,
that is, they will return a zero-length property of type NULL.
(Type NULL means the result of
<B>InternAtom</B>
on the string &quot;NULL&quot;, not the value zero.)
In all cases,
the requested side effect must be performed before the conversion is accepted.
If the requested side effect cannot be performed,
the corresponding conversion request must be refused.
<OL>
<P ALIGN=center> Conventions<P>
<LI> Targets with side effects should return no information
(that is, they should have a zero-length property of type NULL).
<LI> The side effect of a target must be performed before the conversion is accepted.
<LI> If the side effect of a target cannot be performed,
the corresponding conversion request must be refused.
</OL>
<P ALIGN=center> Problem
<BLOCKQUOTE>
<P>The need to delay responding to the 
<B>ConvertSelection </B>
request until a further conversion has succeeded poses problems 
for the Intrinsics interface that need to be addressed.
</BLOCKQUOTE>
<P>
These side effect targets are used to implement operations such as
&quot;exchange PRIMARY and SECONDARY selections.&quot;

<H4><A NAME="s-2.6.3.1">2.6.3.1.</A> DELETE</H4>
When the owner of a selection receives a request to convert it to DELETE,
it should delete the corresponding selection
(whatever doing so means for its internal data structures)
and return a zero-length property of type NULL if the deletion was successful.

<H4><A NAME="s-2.6.3.2">2.6.3.2.</A> INSERT_SELECTION</H4>
When the owner of a selection receives a request to convert it to 
INSERT_SELECTION,
the property named will be of type ATOM_PAIR.
The first atom will name a selection,
and the second will name a target.
The owner should use the selection mechanism to convert the named selection
into the named target and should insert it at the location of the selection
for which it got the INSERT_SELECTION request
(whatever doing so means for its internal data structures).

<H4><A NAME="s-2.6.3.3">2.6.3.3.</A> INSERT_PROPERTY</H4>
When the owner of a selection receives a request to convert it to
INSERT_PROPERTY, 
it should insert the property named in the request at the location 
of the selection for which it got the INSERT_SELECTION request
(whatever doing so means for its internal data structures).

<H2><A NAME="s-2.7">2.7.</A> Use of Selection Properties</H2>
The names of the properties used in selection data transfer are chosen by
the requestor.
The use of 
<B>None </B>
property fields in 
<B>ConvertSelection </B>
requests (which request the selection owner to choose a name)
is not permitted by these conventions.
<P>
The selection owner always chooses the type of the property 
in the selection data transfer.
Some types have special semantics assigned by convention,
and these are reviewed in the following sections.
<P>
In all cases,
a request for conversion to a target should return either
a property of one of the types listed in the previous table for that target
or a property of type INCR and then a property of one of the listed types.
<P>
Certain selection properties may contain resource IDs.  The selection owner
should ensure that the resource is not destroyed and that its contents are
not changed until after the selection transfer is complete.  Requestors that
rely on the existence or on the proper contents of a resource must operate
on the resource (for example, by copying the contents of a pixmap) before
deleting the selection property.
<P>
The selection owner will return a list of zero or more items
of the type indicated by the property type.
In general,
the number of items in the list will correspond to the number 
of disjoint parts of the selection.
Some targets (for example, side-effect targets) will be of length zero
irrespective of the number of disjoint selection parts.
In the case of fixed-size items,
the requestor may determine the number of items by the property size.
Selection property types are listed in the table below.
For variable-length items such as text, 
the separators are also listed.
<TABLE>
<TR><TH COLSPAN=3><HR>
<TR><TH ALIGN=left>Type Atom	<TH ALIGN=left>Format	<TH ALIGN=left>Separator
<TR><TH COLSPAN=3><HR>
<TR><TD>APPLE_PICT	<TD>8	<TD>Self-sizing
<TR><TD>ATOM	<TD>32	<TD>Fixed-size
<TR><TD>ATOM_PAIR	<TD>32	<TD>Fixed-size
<TR><TD>BITMAP	<TD>32	<TD>Fixed-size
<TR><TD>C_STRING	<TD>8	<TD>Zero
<TR><TD>COLORMAP	<TD>32	<TD>Fixed-size
<TR><TD>COMPOUND_TEXT	<TD>8	<TD>Zero
<TR><TD>DRAWABLE	<TD>32	<TD>Fixed-size
<TR><TD>INCR	<TD>32	<TD>Fixed-size
<TR><TD>INTEGER	<TD>32	<TD>Fixed-size
<TR><TD>PIXEL	<TD>32	<TD>Fixed-size
<TR><TD>PIXMAP	<TD>32	<TD>Fixed-size
<TR><TD>SPAN	<TD>32	<TD>Fixed-size
<TR><TD>STRING	<TD>8	<TD>Zero
<TR><TD>WINDOW	<TD>32	<TD>Fixed-size
<TR><TH COLSPAN=3><HR>
</TABLE>

<P>
It is expected that this table will grow over time.

<H3><A NAME="s-2.7.1">2.7.1.</A> TEXT Properties</H3>
In general, 
the encoding for the characters in a text string property is specified 
by its type.
It is highly desirable for there to be a simple, invertible mapping 
between string property types and any character set names
embedded within font names in any font naming standard adopted by the
Consortium.
<P>
The atom TEXT is a polymorphic target.
Requesting conversion into TEXT will convert into whatever encoding 
is convenient for the owner.
The encoding chosen will be indicated by the type of the property returned.
TEXT is not defined as a type;
it will never be the returned type from a selection conversion request.
<P>
If the requestor wants the owner to return the contents of the selection
in a specific encoding,
it should request conversion into the name of that encoding.
<P>
In the table in <A HREF="sec-2.html#s-2.6.2">section 2.6.2</A>,
the word TEXT (in the Type column) is used to indicate one 
of the registered encoding names.
The type would not actually be TEXT;
it would be STRING or some other ATOM naming the encoding chosen by the owner.
<P>
STRING as a type or a target specifies the ISO Latin-1 character set plus the
control characters TAB (octal 11) and NEWLINE (octal 12).
The spacing interpretation of TAB is context dependent.
Other ASCII control characters are explicitly not included in STRING 
at the present time.
<P>
COMPOUND_TEXT as a type or a target specifies the Compound Text interchange
format; see the <I>Compound Text Encoding</I>.
<P>
There are some text objects where the source or intended user, as the
case may be, does not have a specific character set for the text, but
instead merely requires a zero-terminated sequence of bytes with no
other restriction; no element of the selection mechanism may assume that
any byte value is forbidden or that any two differing sequences are
equivalent.<A HREF="footnotes.html#f-8"><SUP>8</SUP></A>
  For these objects, the type C_STRING should be used.
<P ALIGN=center> Rationale
<BLOCKQUOTE>
<P>An example of the need for C_STRING is to transmit the names of
files; many operating systems do not interpret filenames as having
a character set. For example, the same character string uses a
different sequence of bytes in ASCII and EBCDIC, and so most
operating systems see these as different filenames, and offer no
way to treat them as the same. Thus no character-set based
property type is suitable.
</BLOCKQUOTE>
<P>
Type STRING, COMPOUND_TEXT, and C_STRING properties will consist of a list
of elements separated by null characters; other encodings will need to
specify an appropriate list format.

<H3><A NAME="s-2.7.2">2.7.2.</A> INCR Properties</H3>
Requestors may receive a property of type INCR<A HREF="footnotes.html#f-9"><SUP>9</SUP></A>

in response to any target that results in selection data.
This indicates that the owner will send the actual data incrementally.
The contents of the INCR property will be an integer,  
which represents a lower bound on the number of bytes of data in the selection.
The requestor and the selection owner transfer the data in the selection 
in the following manner.
<P>
The selection requestor starts the transfer process by deleting
the (type==INCR) property forming the reply to the selection.
<P>
The selection owner then:
<UL>
<LI> Appends the data in suitable-size chunks to the
same property on the same window as the selection reply
with a type corresponding to the actual type of the converted selection.
The size should be less than the maximum-request-size in the connection
handshake.
<LI> Waits between each append for a 
<B>PropertyNotify (state==Deleted) </B>
event that shows that the requestor has read the data.
The reason for doing this is to limit the consumption of space in the server.
<LI> Waits (after the entire data has been transferred to the server) until a 
<B>PropertyNotify (state==Deleted)</B>
event that shows that the data has been read by the requestor
and then writes zero-length data to the property.
</UL>
The selection requestor:
<UL>
<LI> Waits for the 
<B>SelectionNotify </B>
event.
<LI> Loops:
<UL>
<LI> Retrieving data using 
<B>GetProperty </B>
with the delete argument
<B>True .</B>
<LI> Waiting for a 
<B>PropertyNotify </B>
with the state argument 
<B>NewValue .</B>
</UL>
<LI> Waits until the property named by the
<B>PropertyNotify</B>
event is zero-length.
<LI> Deletes the zero-length property.
</UL>
The type of the converted selection is the type of the first partial property.
The remaining partial properties must have the same type.

<H3><A NAME="s-2.7.3">2.7.3.</A> DRAWABLE Properties</H3>
Requestors may receive properties of type PIXMAP, BITMAP, DRAWABLE, or WINDOW,
which contain an appropriate ID.
While information about these drawables is available from the server by means of
the 
<B>GetGeometry </B>
request,
the following items are not:
<UL>
<LI> Foreground pixel
<LI> Background pixel
<LI> Colormap ID
</UL>
In general,
requestors converting into targets whose returned type in the table 
in <A HREF="sec-2.html#s-2.6.2">section 2.6.2</A> is one of the DRAWABLE types should expect to convert also 
into the following targets (using the MULTIPLE mechanism):
<UL>
<LI> FOREGROUND returns a PIXEL value.
<LI> BACKGROUND returns a PIXEL value.
<LI> COLORMAP returns a colormap ID.

</UL>
<H3><A NAME="s-2.7.4">2.7.4.</A> SPAN Properties</H3>
Properties with type SPAN contain a list of cardinal-pairs
with the length of the cardinals determined by the format.
The first specifies the starting position,
and the second specifies the ending position plus one.
The base is zero.
If they are the same,
the span is zero-length and is before the specified position.
The units are implied by the target atom, 
such as LINE_NUMBER or CHARACTER_POSITION.

<H2><A NAME="s-2.8">2.8.</A> Manager Selections</H2>
Certain clients, often called managers, take on responsibility
for managing shared resources.  A client that manages a shared
resource should take ownership of an appropriate selection,
named using the conventions described in sections <A HREF="sec-1.html#s-1.2.3">1.2.3</A>
and <A HREF="sec-1.html#s-1.2.6">1.2.6</A>.  A client that manages multiple
shared resources (or groups of resources) should take
ownership of a selection for each one.
<P>
The manager may support conversion of various targets
for that selection.  Managers are encouraged to use this
technique as the primary means by which clients interact
with the managed resource.  Note that the conventions for
interacting with the window manager predate this section;
as a result many interactions with the window manager use
other techniques.
<P>
Before a manager takes ownership of a manager selection, it
should use the
<B>GetSelectionOwner</B>
request to check whether the selection is already owned by another client,
and where appropriate, it should ask the user if the new manager should
replace the old one.  If so, it may then take ownership of the selection.
Managers should acquire the selection using a window created expressly for
this purpose.  Managers must conform to the rules for selection owners
described in sections <A HREF="sec-2.html#s-2.1">2.1</A> and <A HREF="sec-2.html#s-2.2">2.2</A>, and they must also support the required
targets listed in <A HREF="sec-2.html#s-2.6.2">section 2.6.2</A>.
<P>
If a manager loses ownership of a manager selection, this
means that a new manager is taking over its responsibilities.
The old manager must release all resources it has managed,
and must then destroy the window that owned the selection.
For example, a window manager losing ownership of WM_S2
must deselect from
<B>SubstructureRedirect</B>
on the root window of screen 2 before destroying the window that owned
WM_S2.
<P>
When the new manager notices that the window owning the selection
has been destroyed, it knows that it can successfully proceed to
control the resource it is planning to manage.  If the old
manager does not destroy the window within a reasonable time,
the new manager should check with the user before destroying
the window itself or killing the old manager.
<P>
If a manager wants to give up, on its own, management of a shared
resource controlled by a selection, it must do so by releasing
the resources it is managing, and then by destroying the
window that owns the selection.  It should not first disown
the selection, since this introduces a race condition.
<P>
Clients who are interesting in knowing when the owner of a
manager selection is no longer managing the corresponding shared
resource should select for
<B>StructureNotify</B>
on the window owning the selection so they can be notified when the window
is destroyed.  Clients are warned that after doing a
<B>GetSelectionOwner</B>
and selecting for
<B>StructureNotify ,</B>
they should do a
<B>GetSelectionOwner</B>
again to ensure that the owner did not change after initially getting the
selection owner and before selecting for 
<B>StructureNotify .</B>
<P>
Immediately after a manager successfully acquires ownership of a
manager selection, it should announce its arrival by sending a
<B>ClientMessage</B>
event.  This event should be sent using the
<B>SendEvent</B>
protocol request with the following arguments:
<TABLE>
<TR><TH COLSPAN=2><HR>
<TR><TH ALIGN=left>Argument	<TH ALIGN=left>Value
<TR><TH COLSPAN=2><HR>
<TR><TD>destination:	<TD>the root window of screen 0, or the root manager is managing a screen-specific resource
<TR><TD>propagate:	<TD>False
<TR><TD>event-mask:	<TD><B>StructureNotify</B>
<TR><TD>event:	<TD><B>ClientMessage</B>
<TR><TD> type:	<TD>MANAGER
<TR><TD> format:	<TD>32
<TR><TD> data[0]:<A HREF="footnotes.html#f-10"><SUP>10</SUP></A>
	<TD>timestamp
<TR><TD> data[1]:	<TD>manager selection atom
<TR><TD> data[2]:	<TD>the window owning the selection
<TR><TD> data[3]:	<TD>manager-selection-specific data
<TR><TD> data[4]:	<TD>manager-selection-specific data
<TR><TH COLSPAN=2><HR>
</TABLE>
<P>
Clients that wish to know when a specific manager has started should
select for
<B>StructureNotify</B>
on the appropriate root window, and should watch for the appropriate MANAGER
<B>ClientMessage .</B>

<HR>
<A HREF="sec-1.html"><IMG SRC="/images/left.gif" WIDTH=31 HEIGHT=31 ALT="<"></A><A HREF="./"><IMG SRC="/images/up.gif" WIDTH=31 HEIGHT=31 ALT="^"></A><A HREF="sec-3.html"><IMG SRC="/images/right.gif" WIDTH=31 HEIGHT=31 ALT=">"></A>
<P><ADDRESS><A HREF="http://tronche.com/">Christophe Tronche</A>, <A HREF="mailto:ch.tronche@computer.org">ch.tronche@computer.org</A></ADDRESS>
</BODY>
</HTML>
