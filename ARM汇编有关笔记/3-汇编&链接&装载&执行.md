## 汇编，链接，装载，执行到底做了什么？

（**注：这部分的内容以ARM64为目标平台**）

强烈推荐去看看CSAPP，这个笔记只对后续用到的部分进行粗略的学习；



一段代码从文本变成可执行文件，需要经历 预编译，编译，汇编，链接，这四个步骤中，这篇笔记着重了解后两步；

首先准备2个C语言文件：main.c和sum.c；（汇编阶段我们以main.c举例）

```c
//main.c
int sum(int *a, int n);

int array[2] = {1,2};

int main()
{
        int val = sum(array,2);
        return val;
}
```

```c
//sum.c
int sum(int *a, int n)
{
        int i, s = 0;
        for(i = 0; i < n; i++)
        {
                s += a[i];
        }
        return s
}
```



对main.c进行编译，生成main.s方便后续分析；请注意，这里的main.s只不过是由main.c翻译而来的由汇编语言写成的代码，main.s只是代码，只是代码，只是代码；

```shell
pi@raspberrypi:$ gcc -S main.c -o main.s
```





### 汇编（as）与ELF文件：

使用as对一个.s（汇编语言编写的代码）进行汇编，会产生一个.o文件（**我们一般称其为“目标文件”**）；这个过程中汇编器做了什么？目标文件里又包含了什么信息？

```shell
#首先将.s文件汇编生成.o文件
aarch64-linux-gnu-as main.s -o main.o
```

`main.s`经过汇编之后生成的`main.o`这个目标文件是ELF格式文件，即executable and linkable format（即可执行与可链接格式）；使用readelf命令可以查看ELF文件的内容；

```shell
pi@raspberrypi:~/test_as_2 $ readelf -a main.o
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00
  Class:                             ELF64
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              REL (Relocatable file)
  Machine:                           AArch64
  Version:                           0x1
  Entry point address:               0x0
  Start of program headers:          0 (bytes into file)
  Start of section headers:          768 (bytes into file)
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           0 (bytes)
  Number of program headers:         0
  Size of section headers:           64 (bytes)
  Number of section headers:         12
  Section header string table index: 11

Section Headers:
  [Nr] Name              Type             Address           Offset
       Size              EntSize          Flags  Link  Info  Align
  [ 0]                   NULL             0000000000000000  00000000
       0000000000000000  0000000000000000           0     0     0
  [ 1] .text             PROGBITS         0000000000000000  00000040
       0000000000000028  0000000000000000  AX       0     0     4
  [ 2] .rela.text        RELA             0000000000000000  00000240
       0000000000000048  0000000000000018   I       9     1     8
  [ 3] .data             PROGBITS         0000000000000000  00000068
       0000000000000008  0000000000000000  WA       0     0     8
  [ 4] .bss              NOBITS           0000000000000000  00000070
       0000000000000000  0000000000000000  WA       0     0     1
  [ 5] .comment          PROGBITS         0000000000000000  00000070
       0000000000000028  0000000000000001  MS       0     0     1
  [ 6] .note.GNU-stack   PROGBITS         0000000000000000  00000098
       0000000000000000  0000000000000000           0     0     1
  [ 7] .eh_frame         PROGBITS         0000000000000000  00000098
       0000000000000038  0000000000000000   A       0     0     8
  [ 8] .rela.eh_frame    RELA             0000000000000000  00000288
       0000000000000018  0000000000000018   I       9     7     8
  [ 9] .symtab           SYMTAB           0000000000000000  000000d0
       0000000000000150  0000000000000018          10    11     8
  [10] .strtab           STRTAB           0000000000000000  00000220
       000000000000001d  0000000000000000           0     0     1
  [11] .shstrtab         STRTAB           0000000000000000  000002a0
       0000000000000059  0000000000000000           0     0     1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),
  L (link order), O (extra OS processing required), G (group), T (TLS),
  C (compressed), x (unknown), o (OS specific), E (exclude),
  p (processor specific)

There are no section groups in this file.

There are no program headers in this file.

There is no dynamic section in this file.

Relocation section '.rela.text' at offset 0x240 contains 3 entries:
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
00000000000c  000b00000113 R_AARCH64_ADR_PRE 0000000000000000 array + 0
000000000010  000b00000115 R_AARCH64_ADD_ABS 0000000000000000 array + 0
000000000014  000d0000011b R_AARCH64_CALL26  0000000000000000 sum + 0

Relocation section '.rela.eh_frame' at offset 0x288 contains 1 entry:
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
00000000001c  000200000105 R_AARCH64_PREL32  0000000000000000 .text + 0

The decoding of unwind sections for machine type AArch64 is not currently supported.

Symbol table '.symtab' contains 14 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND
     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS main.c
     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1
     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3
     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4
     5: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT    3 $d
     6: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT    1 $x
     7: 0000000000000000     0 SECTION LOCAL  DEFAULT    6
     8: 0000000000000014     0 NOTYPE  LOCAL  DEFAULT    7 $d
     9: 0000000000000000     0 SECTION LOCAL  DEFAULT    7
    10: 0000000000000000     0 SECTION LOCAL  DEFAULT    5
    11: 0000000000000000     8 OBJECT  GLOBAL DEFAULT    3 array
    12: 0000000000000000    40 FUNC    GLOBAL DEFAULT    1 main
    13: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND sum

No version information found in this file.
```

其中：



#### elf文件的elf header

elf头中包含的诸多内容中较为重要的是：

Magic：魔数，这个值决定了该文件的格式；例如java文件的Magic就是cafebabe（coffee baby），只有以cafebabe开头的文件才会被java虚拟机认为是java程序；

Class：文件类型，表明这个文件是64elf还是32elf

Data：大小端等信息

Type ELF：说明文件是Relocatable file还是Executable file（可执行文件）还是shared object file（共享对象文件）还是core dump file（core dump文件）；例子中这个文件是relocatable file（可重定位文件）

Entry point address：入口指针，这个值指向程序的入口，因为目前我们分析的是一个可重定位文件而非可执行文件，因此没有入口，所以这里是0x00

Start of section headers：表示段表（section table）的起始地址；这个例子中888（换算成十六进制是0x378）



#### elf文件的section header

section header中记录了程序的“段信息”（也就是我们常说的数据段，代码段...的段信息）；

段信息包括：

```c
// /usr/include/elf.h中定义了section header的结构体

typedef struct
{
  Elf64_Word    sh_name;                /* Section name (string tbl index) */
  Elf64_Word    sh_type;                /* Section type */
  Elf64_Xword   sh_flags;               /* Section flags */
  Elf64_Addr    sh_addr;                /* Section virtual addr at execution */
    //请注意，在没有进行链接的阶段，Address均为0x00
  Elf64_Off     sh_offset;              /* Section file offset */
  Elf64_Xword   sh_size;                /* Section size in bytes */
  Elf64_Word    sh_link;                /* Link to another section */
  Elf64_Word    sh_info;                /* Additional section information */  Elf64_Xword   sh_addralign;           /* Section alignment */
  Elf64_Xword   sh_entsize;             /* Entry size if section holds table */
} Elf64_Shdr;

```

我们的例子中有11个段（Nr=0的那个不算）：.text（代码段），.rela.text（需要重定位的指令），.data（数据段），.bss（未初始化数据段），.comment（存放编译器版本信息），.note.GNU-stack，.eh_frame（），.rela.eh_frame（），.symtab（符号表），.strtab（字符串表），.shstrtab（section header string table）；

详细说明一下其中部分表的作用：

rela.text：用于保存text段需要重定位的指令；

data数据段：保存 已经初始化的全局变量 和 已经初始化的局部静态变量（注意：这里只存放这两种数据，普通的局部变量并不会放在data里）

bss未初始化数据段：保存 未初始化的全局变量 和 未初始化的局部静态变量（注意：初始化为0 会被视为没有初始化...）bss段实际上在这个阶段是不占位置的

strtab字符串表：这个段中会存储elf文件中用到的各种字符串

section header中给出了各个段的offset（偏移地址），所以我们可以直观的看到经过汇编之后的elf文件的数据信息分布：

| elf header      | 起始偏移地址：00000000                                       |
| --------------- | ------------------------------------------------------------ |
| .text           | 起始偏移地址：0x40；size=0x28                                |
| .data           | 起始偏移地址：0x68；size=0x08                                |
| .bss            | 起始偏移地址：0x70；size=0x00                                |
| 注：            | .bss实际上是没有占位置的，如果本例中bss的size不等于0，comment段的起始位置也不会受到bss的size的影响 |
| .comment        | 起始偏移地址：0x70；size=0x28                                |
| .note.GNU-stack | 起始偏移地址：0x98；size=0x00                                |
| .eh_frame       | 起始偏移地址：0x98；size=0x38                                |
| .symtab         | 起始偏移地址：0xd0；size=0x150                               |
| .strtab         | 起始偏移地址：0x220；size=0x1d                               |
| 注：            | 0x220+0x1d=0x23d，但.rela.text的偏移地址是0x240；中间空缺<br>的2个字节应该由于内存对齐引起的(4字节对齐) |
| .rela.text      | 起始偏移地址：0x240；size=0x48                               |
| .rela.eh_frame  | 起始偏移地址：0x288；size=0x18                               |
| .shstrtab       | 起始偏移地址：0x2a0；size=0x59                               |

**这里要注意，在完成汇编之后，各个段虽然拿到了偏移地址，但是Address（虚拟地址）还是0**



#### elf文件中.text段中的具体内容

text段即为代码段，这个段中存储着程序中的代码；

使用objdump对main.o进行反汇编可以看到代码段的内容

````shell
# objdump的使用
objdump -s -d main.o # -s表明段以十六进制打印出来，-d表示反汇编
````

````shell
pi@raspberrypi:~/test_as_2 $ objdump -s -d main.o
#...
0000000000000000 <main>:
   0:   a9be7bfd        stp     x29, x30, [sp, #-32]!
   4:   910003fd        mov     x29, sp
   8:   52800041        mov     w1, #0x2                        // #2
   c:   90000000        adrp    x0, 0 <main>
  10:   91000000        add     x0, x0, #0x0
  14:   94000000        bl      0 <sum>
  18:   b9001fe0        str     w0, [sp, #28]
  1c:   b9401fe0        ldr     w0, [sp, #28]
  20:   a8c27bfd        ldp     x29, x30, [sp], #32
  24:   d65f03c0        ret
````

关注一下偏移地址为0x0c，0x10，0x14这3条指令

```assembly
#...
#偏移地址 机器码		指令		操作数
   c:   90000000        adrp    x0, 0 <main>
  10:   91000000        add     x0, x0, #0x0
  14:   94000000        bl      0 <sum>
#...
```

这几条指令明显的对应着C语言中的

```c
 int val = sum(array,2);
```

从机器码的角度看，这三条指令操作码后的内容是0，也就是说这几条指令引用的符号地址是0，0当然不可能是符号真正的地址；

为什么会这样？因为这一句代码中使用了`sum`函数，而`sum`函数在main.c中没有定义，汇编器无法确定符号地址；

这个地址，在链接的时候才会被具体的设置；



#### elf文件中.symtab符号表的详细说明

使用readelf -s [文件名]可以查看符号表

```shell
pi@raspberrypi:~/test_as_2 $ readelf -s main.o

Symbol table '.symtab' contains 14 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND
     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS main.c
     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1
     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3
     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4
     5: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT    3 $d
     6: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT    1 $x
     7: 0000000000000000     0 SECTION LOCAL  DEFAULT    6
     8: 0000000000000014     0 NOTYPE  LOCAL  DEFAULT    7 $d
     9: 0000000000000000     0 SECTION LOCAL  DEFAULT    7
    10: 0000000000000000     0 SECTION LOCAL  DEFAULT    5
    11: 0000000000000000     8 OBJECT  GLOBAL DEFAULT    3 array
    12: 0000000000000000    40 FUNC    GLOBAL DEFAULT    1 main
    13: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND sum
```

符号表将在链接过程中起着无比重要的作用；符号表的结构被定义在/usr/include/elf.h中的

```c
//  /usr/include/elf.h
typedef struct
{
  Elf64_Word    st_name;                /* Symbol name (string tbl index) */
  unsigned char st_info;                /* Symbol type and binding */
  unsigned char st_other;               /* Symbol visibility */
  Elf64_Section st_shndx;               /* Section index */
  Elf64_Addr    st_value;               /* Symbol value */
  Elf64_Xword   st_size;                /* Symbol size */
} Elf64_Sym;
```

这是64位的elf符号表的结构

其中：

st_name：符号名

st_info：符号类型和绑定信息

st_other：符号能见度？（这个貌似目前也没用到...）

st_shndx：符号所在的段目录（即符号在哪个段，如果这个符号就在本文件里；那么这里的值就是符号所在的段，例如text或者data等..但是如果这个符号不是本文件里的，需要从外部链接，则会有所不同，下文详细介绍）

st_value：符号的值

st_size：符号的大小，对于包含着数据的符号这个值则表示数据的长度；



**符号类型与绑定（st_info）：**

```c
//同样是定义在/usr/include/elf.h中的
/* Legal values for ST_BIND subfield of st_info (symbol binding).  */

#define STB_LOCAL       0               /* Local symbol */
#define STB_GLOBAL      1               /* Global symbol */
#define STB_WEAK        2               /* Weak symbol */
#define STB_NUM         3               /* Number of defined types.  */
#define STB_LOOS        10              /* Start of OS-specific */
#define STB_GNU_UNIQUE  10              /* Unique symbol.  */
#define STB_HIOS        12              /* End of OS-specific */
#define STB_LOPROC      13              /* Start of processor-specific */
#define STB_HIPROC      15              /* End of processor-specific */

/* Legal values for ST_TYPE subfield of st_info (symbol type).  */

#define STT_NOTYPE      0               /* Symbol type is unspecified */
#define STT_OBJECT      1               /* Symbol is a data object */
#define STT_FUNC        2               /* Symbol is a code object */
#define STT_SECTION     3               /* Symbol associated with a section */
#define STT_FILE        4               /* Symbol's name is file name */
#define STT_COMMON      5               /* Symbol is a common data object */
#define STT_TLS         6               /* Symbol is thread-local data object*/
#define STT_NUM         7               /* Number of defined types.  */
#define STT_LOOS        10              /* Start of OS-specific */
#define STT_GNU_IFUNC   10              /* Symbol is indirect code object */
#define STT_HIOS        12              /* End of OS-specific */
#define STT_LOPROC      13              /* Start of processor-specific */
#define STT_HIPROC      15              /* End of processor-specific */
```

从定义来看，符号的绑定 指的是符号的生效范围，是local，global，或者是weak；

符号类型 实际上是相当丰富的，可以是未定义，可以是一个对象，可以是一个函数，一个文件，一个段等等...



**符号所在段（st_shndx）：**

```c
/* Special section indices.  */

#define SHN_UNDEF       0               /* Undefined section */
#define SHN_LORESERVE   0xff00          /* Start of reserved indices */
#define SHN_LOPROC      0xff00          /* Start of processor-specific */
#define SHN_BEFORE      0xff00          /* Order section before all others
                                           (Solaris).  */
#define SHN_AFTER       0xff01          /* Order section after all others
                                           (Solaris).  */
#define SHN_HIPROC      0xff1f          /* End of processor-specific */
#define SHN_LOOS        0xff20          /* Start of OS-specific */
#define SHN_HIOS        0xff3f          /* End of OS-specific */
#define SHN_ABS         0xfff1          /* Associated symbol is absolute */
#define SHN_COMMON      0xfff2          /* Associated symbol is common */
#define SHN_XINDEX      0xffff          /* Index is in extra table.  */
#define SHN_HIRESERVE   0xffff          /* End of reserved indices */
```

常用的特殊段有：

SHN_ABS：符号包含了一个绝对值

SHN_COMMON：表示这类的符号要在链接的时候被处理；（如果定义了一个未初始化的全局变量，这个变量就会被归到这里）

SHN_UNDEF：表示这个符号没有被定义，需要到其他的文件中找

**符号值（st_value）**

如果符号是一个函数或者是一个变量，那么符号的值就是这个符号的**地址**；

1. （对于目标文件）如果符号不是上面说的common类型的，那么符号值是**段中的 偏移地址**
2. （对于目标文件）如果符号是common类型的，那么符号值是符号的"对齐属性"
3. （对于可执行文件）st_value是符号的虚拟地址；

#### elf文件中.strtab字符串表

使用readelf -x 指定打印strtab信息

```shell
pi@raspberrypi:~/test_as_2 $ readelf -x 10 main.o

Hex dump of section '.strtab':
  0x00000000 006d6169 6e2e6300 24640024 78006172 .main.c.$d.$x.ar
  0x00000010 72617900 6d61696e 0073756d 00       ray.main.sum.
```

strtab的中的字符串是代码中用到的字符串，诸如函数的名字（例如main函数使用的"main"就可以在这里被找到），变量的名字（例如程序中声明的数组的名字”array“可以在这被找到），还有文件的名字（main.c）；

**但是 strtab段 不包括程序中用于输出的字符串！（如果程序中有printf("helloworld")之类的代码，那么"helloworld"这个字符串将会被放在.rodata中）**

要注意这个段里的内容实际上是连续的，这样我们只需要用strtab段的基地址+偏移地址就能取到这个段中的所有字符串



### 静态链接（ld）：



#### 为什么要链接？

汇编阶段结束后，会发现两个问题：

1. 查看符号表会发现有一些符号的类型是未定义类型；
2. 查看代码段内容，发现有一些机器码使用了假地址；

引起这两个问题的原因是，编译的时候，有一些符号定义在另一个文件里；（例如main.c中用到的函数`sum`定义在sum.c中）

为了解决这个问题，就需要进行链接，将几个文件撮成一个完整的文件；

如此一来只要程序没写错，那么所有的符号就都能在一个文件中被找到，这样就不再会有未定义的符号，之前未定义的符号暂定的假地址也可以被重新分配地址；



#### 链接器如何把多个文件捏成一个？

方法有两种：

1. 将每个elf文件头尾相连拼在一起，这种方法执行起来简单，但是由于内存页对齐的问题，会造成极大的内存浪费；

2. 将每个elf文件中相同的段合并在一起，这种方法规避了内存的浪费，但是需要重新对文件中的数据和符号进行重新解析和重定位；

目前通用的方法是第二种方法；

使用链接器完成链接，将两个目标文件 链接 成一个 可执行文件

```shell
ld main.o sum.o -e main -o main #-e指定程序入口，也就是入口函数
```



#### 静态链接到底做了什么？

静态链接的主要任务有2个：

1. 空间和地址的分配；
2. 符号的解析与重定位；

接下来对可执行文件`main`进行分析



#### 1.静态链接->空间和地址的分配

````shell
pi@raspberrypi:~/test_as_2 $ readelf -a main
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00
  Class:                             ELF64
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              EXEC (Executable file)
  Machine:                           AArch64
  Version:                           0x1
  Entry point address:               0x400120
  Start of program headers:          64 (bytes into file)
  Start of section headers:          4800 (bytes into file)
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           56 (bytes)
  Number of program headers:         4
  Size of section headers:           64 (bytes)
  Number of section headers:         8
  Section header string table index: 7

Section Headers:
  [Nr] Name              Type             Address           Offset
       Size              EntSize          Flags  Link  Info  Align
  [ 0]                   NULL             0000000000000000  00000000
       0000000000000000  0000000000000000           0     0     0
  [ 1] .text             PROGBITS         0000000000400120  00000120
       0000000000000088  0000000000000000  AX       0     0     4
  [ 2] .eh_frame         PROGBITS         00000000004001a8  000001a8
       0000000000000050  0000000000000000   A       0     0     8
  [ 3] .data             PROGBITS         0000000000410fe8  00000fe8
       0000000000000008  0000000000000000  WA       0     0     8
  [ 4] .comment          PROGBITS         0000000000000000  00000ff0
       0000000000000027  0000000000000001  MS       0     0     1
  [ 5] .symtab           SYMTAB           0000000000000000  00001018
       0000000000000210  0000000000000018           6    12     8
  [ 6] .strtab           STRTAB           0000000000000000  00001228
       000000000000005d  0000000000000000           0     0     1
  [ 7] .shstrtab         STRTAB           0000000000000000  00001285
       000000000000003a  0000000000000000           0     0     1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),
  L (link order), O (extra OS processing required), G (group), T (TLS),
  C (compressed), x (unknown), o (OS specific), E (exclude),
  p (processor specific)

There are no section groups in this file.

Program Headers:
  Type           Offset             VirtAddr           PhysAddr
                 FileSiz            MemSiz              Flags  Align
  LOAD           0x0000000000000000 0x0000000000400000 0x0000000000400000
                 0x00000000000001f8 0x00000000000001f8  R E    0x10000
  LOAD           0x0000000000000fe8 0x0000000000410fe8 0x0000000000410fe8
                 0x0000000000000008 0x0000000000000008  RW     0x10000
  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000
                 0x0000000000000000 0x0000000000000000  RW     0x10
  GNU_RELRO      0x0000000000000fe8 0x0000000000410fe8 0x0000000000410fe8
                 0x0000000000000008 0x0000000000000018  R      0x1

 Section to Segment mapping:
  Segment Sections...
   00     .text .eh_frame
   01     .data
   02
   03     .data

There is no dynamic section in this file.

There are no relocations in this file.

The decoding of unwind sections for machine type AArch64 is not currently supported.

Symbol table '.symtab' contains 22 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND
     1: 0000000000400120     0 SECTION LOCAL  DEFAULT    1
     2: 00000000004001a8     0 SECTION LOCAL  DEFAULT    2
     3: 0000000000410fe8     0 SECTION LOCAL  DEFAULT    3
     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4
     5: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS main.c
     6: 0000000000410fe8     0 NOTYPE  LOCAL  DEFAULT    3 $d
     7: 0000000000400120     0 NOTYPE  LOCAL  DEFAULT    1 $x
     8: 00000000004001bc     0 NOTYPE  LOCAL  DEFAULT    2 $d
     9: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS sum.c
    10: 0000000000400148     0 NOTYPE  LOCAL  DEFAULT    1 $x
    11: 00000000004001e0     0 NOTYPE  LOCAL  DEFAULT    2 $d
    12: 0000000000410ff0     0 NOTYPE  GLOBAL DEFAULT    3 _bss_end__
    13: 0000000000400148    96 FUNC    GLOBAL DEFAULT    1 sum
    14: 0000000000410ff0     0 NOTYPE  GLOBAL DEFAULT    3 __bss_start__
    15: 0000000000410ff0     0 NOTYPE  GLOBAL DEFAULT    3 __bss_end__
    16: 0000000000410ff0     0 NOTYPE  GLOBAL DEFAULT    3 __bss_start
    17: 0000000000400120    40 FUNC    GLOBAL DEFAULT    1 main
    18: 0000000000410ff0     0 NOTYPE  GLOBAL DEFAULT    3 __end__
    19: 0000000000410fe8     8 OBJECT  GLOBAL DEFAULT    3 array
    20: 0000000000410ff0     0 NOTYPE  GLOBAL DEFAULT    3 _edata
    21: 0000000000410ff0     0 NOTYPE  GLOBAL DEFAULT    3 _end

No version information found in this file.
````

1. 可以发现相对于main.o；test中的**Section Headers里**，text段，data段等的**Address不再是0**；Address表示的虚拟地址，这表明，经过链接，这些段已经获得了虚拟地址；
2. 相对于main.o这样的REL（可重定位文件），test这样的EXEC（可执行文件）多了一个Program Headers；其中有两个load；第一个load加载虚拟地址0x400000；第二个load加载0x410fe8；如果在section header中查找会发现0x410fd8对应的是.data段；那么0x400000是什么？每个可执行ELF文件，使用的都是虚拟地址；并且对于不同的ELF而言，虚拟地址是独立的，对于64位的ELF文件而言，进程的虚拟地址就是从0x400000开始分配的（对32位文件而言是0x08048000开始）

同时，在链接时，链接器会将各个目标文件中的相同的段进行合并

##### EXEC文件的.text段

查看main(EXEC文件)的`.text`段：

```shell
pi@raspberrypi:~/test_as_2 $ objdump -s -d main
#...
Disassembly of section .text:

0000000000400120 <main>:
  400120:       a9be7bfd        stp     x29, x30, [sp, #-32]!
  400124:       910003fd        mov     x29, sp
  400128:       52800041        mov     w1, #0x2                        // #2
  40012c:       90000080        adrp    x0, 410000 <sum+0xfeb8>
  400130:       913fa000        add     x0, x0, #0xfe8
  400134:       94000005        bl      400148 <sum>
  400138:       b9001fe0        str     w0, [sp, #28]
  40013c:       b9401fe0        ldr     w0, [sp, #28]
  400140:       a8c27bfd        ldp     x29, x30, [sp], #32
  400144:       d65f03c0        ret

0000000000400148 <sum>:
  400148:       d10083ff        sub     sp, sp, #0x20
  40014c:       f90007e0        str     x0, [sp, #8]
  400150:       b90007e1        str     w1, [sp, #4]
  400154:       b9001bff        str     wzr, [sp, #24]
  400158:       b9001fff        str     wzr, [sp, #28]
  40015c:       1400000c        b       40018c <sum+0x44>
  400160:       b9801fe0        ldrsw   x0, [sp, #28]
  400164:       d37ef400        lsl     x0, x0, #2
  400168:       f94007e1        ldr     x1, [sp, #8]
  40016c:       8b000020        add     x0, x1, x0
  400170:       b9400000        ldr     w0, [x0]
  400174:       b9401be1        ldr     w1, [sp, #24]
  400178:       0b000020        add     w0, w1, w0
  40017c:       b9001be0        str     w0, [sp, #24]
  400180:       b9401fe0        ldr     w0, [sp, #28]
  400184:       11000400        add     w0, w0, #0x1
  400188:       b9001fe0        str     w0, [sp, #28]
  40018c:       b9401fe1        ldr     w1, [sp, #28]
  400190:       b94007e0        ldr     w0, [sp, #4]
  400194:       6b00003f        cmp     w1, w0
  400198:       54fffe4b        b.lt    400160 <sum+0x18>  // b.tstop
  40019c:       b9401be0        ldr     w0, [sp, #24]
  4001a0:       910083ff        add     sp, sp, #0x20
  4001a4:       d65f03c0        ret
```

可见链接将main.o中的`.text`和sum.o中的`.text`放在了一起，他们的地址是连贯的；可见链接并没有粗暴的将两个文件首尾相接，而是对同类段进行了归纳和整理；



##### EXEC文件的.data段

```shell
#main.o中的数据段
pi@raspberrypi:~/test_as_2 $ readelf -x 3 main.o

Hex dump of section '.data':
  0x00000000 01000000 02000000                   ........
  
  
# sum.o的数据段（这个例子中sum.c中没有会被写入数据段的内容...）
pi@raspberrypi:~/test_as_2 $ readelf -x 2 sum.o
Section '.data' has no data to dump.

# main的数据段
pi@raspberrypi:~/test_as_2 $ readelf -x 3 main

Hex dump of section '.data':
  0x00410fe8 01000000 02000000                   ........
```

根据data段的规则:

main.o中的data段存放的应该是数组array={1,2}；

sum.o中data段是空的

main中的data段，将上述两者的data段进行了整合；（这个例子中sum.o的数据段是空的...如果sum.o的数据段中有内容的话，这里也能看到链接后的文件会将其整合）

*（注：这里要说明一下为什么0x01000000=1，0x02000000=2；这个现象是由于小端模式引起的，01 00 00 00在内存中的分布如下*

| *01* | *00* | *00* | *00* |
| ---- | ---- | ---- | ---- |

*小端模式读取的时候应当以字节为单位，从后向前读取；也就是00 00 00 01）*



**当链接器将各个目标文件中的相同段进行了合并，每个符号就都拥有了唯一的地址，此时再也没有所谓的未知符号（当然前提时程序没写错...）**



#### 2.静态链接->符号的重定位

在完成了汇编之后，我们通过查看ELF的.rela段就可以找到有哪些符号需要重定位；在汇编阶段，汇编器如果遇到一个地址不能确定的符号引用，就会生成一个重定位条目，并将之记录在.rela段中；

通过使用readelf -r [文件名]去查看，一个**目标文件中**的**.rela段**，可以查看**目标文件**中有哪些label需要重定位，以main.o为例：

```shell
pi@raspberrypi:~/test_as_2 $ readelf -r main.o

Relocation section '.rela.text' at offset 0x240 contains 3 entries:
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
00000000000c  000b00000113 R_AARCH64_ADR_PRE 0000000000000000 array + 0
000000000010  000b00000115 R_AARCH64_ADD_ABS 0000000000000000 array + 0
000000000014  000d0000011b R_AARCH64_CALL26  0000000000000000 sum + 0

Relocation section '.rela.eh_frame' at offset 0x288 contains 1 entry:
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
00000000001c  000200000105 R_AARCH64_PREL32  0000000000000000 .text + 0
```

上述信息表明这文件里，在.text和.eh_frame中有需要重定位的符号；



##### .rela中包含什么信息？

.rela被定义在elf.h中

````c
// 在/usr/include/elf.h中可以找到rela的结构体定义

/* I have seen two different definitions of the Elf64_Rel and
   Elf64_Rela structures, so we'll leave them out until Novell (or
   whoever) gets their act together.  */
typedef struct
{
  Elf64_Addr    r_offset;               /* Address */
  Elf64_Xword   r_info;                 /* Relocation type and symbol index */
} Elf64_Rel;
typedef struct
{
  Elf64_Addr    r_offset;               /* Address */
  Elf64_Xword   r_info;                 /* Relocation type and symbol index */
  Elf64_Sxword  r_addend;               /* Addend */
} Elf64_Rela;
/*关于Rel与Rela，用哪个取决于你的架构，ARM用的是Rela；*/
/*Rel与Rela的区别只有r_addend这个参数，这个参数是一个加数，对于使用Rela的处理器，用户需要手动的指定这个加数；但是用Rel的处理器并不是没有这个参数...他们只是根据处理器架构给这个参数设置了一个默认值*/
````

```c
//关于r_info的一些代码
#define ELF64_R_SYM(i)                  ((i) >> 32)	//重定位条目的符号表的索引
#define ELF64_R_TYPE(i)                 ((i) & 0xffffffff) //重定位入口的type（这个type决定了重定位的算法）
#define ELF64_R_INFO(sym,type)          ((((Elf64_Xword) (sym)) << 32) + (type))
```

**r_offset：**重定位符号引用 在自己的段内的偏移地址；（例如某句代码引用了一个重定位条目符号，那么r_offset就是该句代码在代码段中的偏移地址）

**r_info：**从elf.h的定义来看，r_info的高32位是 重定位条目（也就是需要被重定位的符号） 在 符号表中的偏移地址；低32位是重定位条目的类型（这个类型决定了要以什么样的算法去计算重定位地址），重定位类型还是比较多的，在静态链接中最重要的类型有两个：1.相对地址的重定位；2.绝对地址的重定位；https://github.com/ARM-software/abi-aa/blob/main/aaelf64/aaelf64.rst#relocation-codes 中详细记录了各中不同的类型和对应的计算方法

**r_addend：**这个参数就是一个固定的常数；

注：重定位的计算公式会涉及到以下几个东西：

S：指的是符号的地址

A：r_addend

P：引用符号的运行时地址



#### 重定位例子具体分析：

具体分析2个例子：

在main.o中的.rela段中有如下信息：

```shell
pi@raspberrypi:~/test_as_2 $ readelf -r main.o

Relocation section '.rela.text' at offset 0x240 contains 3 entries:
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
00000000000c  000b00000113 R_AARCH64_ADR_PRE 0000000000000000 array + 0
000000000010  000b00000115 R_AARCH64_ADD_ABS 0000000000000000 array + 0
000000000014  000d0000011b R_AARCH64_CALL26  0000000000000000 sum + 0
#...
```

有三个重定位条目；重定位类型根据Info的低32位可以确定（ 查阅 https://github.com/ARM-software/abi-aa/blob/main/aaelf64/aaelf64.rst#relocation-codes ）

1. 0x113 -> R_<CLS>_ ADR_PREL_PG_HI21 -> 计算公式：Page(S+A)-Page(P)
2. 0x115 -> R_<CLS>_ ADD_ABS_LO12_NC -> 计算公式：S + A
3. 0x11b -> R_<CLS>_CALL26 -> 计算公式：S+A-P

其中1和2共同完成了一个绝对地址的重定位（根据文档对R_<CLS>_ ADR_PREL_PG_HI21类型的描述，这个类型和R_<CLS>_ ADD_ABS_LO12_NC类型是搭配在一起使用的）

3完成了一个相对地址的重定位



##### 实例1：绝对地址重定位

``` shell
# readelf -r main.o
   Offset          Info           Type           Sym. Value    Sym. Name + Addend
00000000000c  000b00000113 R_AARCH64_ADR_PRE 0000000000000000 array + 0
000000000010  000b00000115 R_AARCH64_ADD_ABS 0000000000000000 array + 0
# 首先分析第2行代码
# 由r_info的高32位可知，需要被重定位的符号在符号表中的偏移地址是0x0b；查找可知是array
# 由r_info的低32位可知，对应的type是0x113，查阅资料可知是R_<CLS>_ ADR_PREL_PG_HI21，对应的计算公式是：Page(S+A)-Page(P)
# 这里的S是符号array的虚拟地址，0x410fe8；A是addend，0；Page(expr)的算法是将低12位归零；因此Page(S+A) = 0x410000
# P是这句代码的地址0x40012c；Page(P) = 0x400000
# 重定位的结果是0x010000；

# 对第3行进行分析
# 由r_info的低32位可知，对应的type是0x115，查阅资料可知是R_AARCH64_ADD_ABS_LO12_NC，对应的计算公式是：S + A（从Type也可以看到是R_AARCH64_ADD_ABS）
# S是符号array在符号表中的虚拟地址，0x410fe8
# A是附加常量addend，这里是0
# 因此重定位的结果应该是0x41 0f e8
```

让我们对照一下链接前后的情况：

```shell
# 链接之前 objdump -s -d main.o
   c:   90000000        adrp    x0, 0 <main>
  10:   91000000        add     x0, x0, #0x0
# 链接之后 objdump -s -d main
 40012c:       90000080        adrp    x0, 410000 <sum+0xfeb8>
 400130:       913fa000        add     x0, x0, #0xfe8
```

1. **关于第一条adrp指令，objdump可能出现了一些错误**：查阅 https://developer.arm.com/documentation/ddi0596/2021-12/Base-Instructions/ADRP--Form-PC-relative-address-to-4KB-page-?lang=en 可以看到adrp的格式如下：

   | 31   | 30：29                 | 28：24 | 23：5                   | 4：0 |
   | ---- | ---------------------- | ------ | ----------------------- | ---- |
   | 1    | 立即数的低2位（immlo） | 10000  | 立即数的高19位（immhi） | Rd   |

   根据这个规则，机器码是0x90 00 00 80；那么立即数应该是0x10（注意！二进制1000=0x10）；因此代码应该是 `adrp x0，0x10`而非objdump中显示的`adrp    x0, 410000 <sum+0xfeb8>`；这里我们以机器码为准，机器码中的立即数是0x10，根据adrp的机制，立即数在使用的时候应当左移12位，也就是0x10000（与我们计算得到的重定位的结果相同）；

   adrp的机制：

   step1：将PC的低12bits清零，也就是0x40012c -> 0x400000

   step2：将立即数左移12bits

   step3：将两者相加，结果存入目标寄存器

   因此目标寄存器X0中会被存入0x410000

   

2.  关于第二条命令add：由于第一条指令已经在X0寄存器中写入了0x410000，再加上0xfe8，X0中的内容实际上就是S + A的值；也就是符号`array`的虚拟地址；

这两条命令，最后的目的就是在于将array的地址，直接放在X0寄存器中，以供后续的程序调用；虽然adrp指令使用了PC，但最后得到的结果仍旧是S + A，因此并不是相对地址重定位，而是两条命令共同完成了一个绝对地址重定位；至于为什么费这么大的周折，请参照下文->*问什么要区分相对地址与绝对地址* 和 *ARM64中的特殊重定位手段*



##### 实例2：相对地址重定位

对本例中，对函数`sum`的重定位就是一个相对地址的重定位

```shell
# readelf -r main.o
   Offset          Info           Type           Sym. Value    Sym. Name + Addend
000000000014  000d0000011b R_AARCH64_CALL26  0000000000000000 sum + 0
# 查表可知r_info低32位（0x11b）对应的type是R_AARCH64_CALL26
# 对应的计算公式是：S + A - P
# S是符号sum在符号表中的地址：0x400148
# A是附加常数，0
# P是当程序运行到这句代码的时候，PC指向的地址；链接后这句代码的地址是0x400134

# S + A - P = 0x400148 + 0 - 0x400134 = 0x14

```

对照一下链接前后的情况

```shell
# 链接前 objdump -s -d main.o
14:   94000000        bl      0 <sum>
# 链接后 objdump -s -d main
400134:       94000005        bl      400148 <sum>

```

**此时结果看起来好像不太对？为什么我们算出来是0x14，而机器码中填入的确是00 00 05？**

**这个现象是由BL指令的机制引起的**

https://developer.arm.com/documentation/ddi0596/2021-12/Base-Instructions/BL--Branch-with-Link-?lang=en（BL指令官方文档）

从上述文档中，可以看到BL的机器码遵循以下格式

| 31:26  | 25:0           |
| ------ | -------------- |
| 100101 | 26bits的立即数 |

BL指令会无条件的跳转到：当前位置 + （立即数 * 4）的位置；

也就是会跳转到：0x400134 + 0x05 * 0x04 = 0x400148；查看main的代码段，会发现0x400148正好是函数`sum`的起始地址；由此看来重定位完美的完成了任务；



#### 为什么要区分相对地址和绝对地址？

相对地址重定位，公式是S+A-P：这个公式最后计算得到的实际上是`符号地址（S）`与`PC地址（P）`之间的差值；这种方式会用于类似于`BL`这样的转跳指令；因为这类指令的实现逻辑就是`PC+立即数`转调至目标，其中立即数是PC与目标之间的差值；

绝对地址重定位，公式是S+A：这个公式得到的就是`符号地址`这个地址和PC没有任何关系；这种方式会用于类似于MOV这类操作，实现逻辑和PC没有任何关系，立即数 指向哪里就去哪里取数据；



##### 为什么ARM64中绝对地址寻址需要多条指令才能完成？

这个问题和 **ARM64的寻址范围** 以及 **ARM64的编码方式** 有关....

毫无疑问ARM64的寻址范围高达2^64；这意味着在不考虑诸如内核空间等问题的情况下数据可能出现在0~2^64之间的任何一个位置；而ARM64的编码方式仍旧是32-bit编码，这又意味着一条ARM指令中不可能放下64-bit的立即数，甚至都不能放下32-bit的立即数；因此，我们无法 只用一条指令 就将 一个表示地址的64bits立即数 放到寄存器中！

（对应的，相对地址寻址可以用一条指令完成，但是如果去仔细查看BL的指令说明，会发现BL的寻址能力实际上是有限的，他只能对PC ±4KB范围内的符号进行寻址，一旦超出这个范围，BL就找不到目标了）

为了解决这个问题，ARM提供了很多种解决方案，这些方案的核心思想就在于，分多次将立即数存入寄存器；

可以举两个例子：

###### 解决方案1

例如可以将一个64bits的立即数砍成4段，用4条指令一段一段的送入同一个寄存器；

参考文章：

https://stackoverflow.com/questions/38570495/aarch64-relocation-prefixes/38608738#38608738

（部分翻译）

*...*

*Aarch64重定位必须解决立即数的问题，实际上重定位问题实际上是涉及到两个问题：1是找到程序想要使用的真正的值（这个问题是纯粹的重定位的问题）；2是需要一个能将这个值放入寄存器的方法，因为任何指令都不可能直接容纳长达64bits的 立即数 ；*

*第二个问题可以使用group relocation解决，一个group中每个重定位类型都被用于计算 64bits值中的16bits的部分；因此在一个group中，只有4中重定位的类型（从G0排到G3）（**李富贵注：根据我的理解，所谓的group relocation，将一个64bits的地址，砍成4段，每段16bits，拼起来就能拼成完整的64bits，正好汇编指令里提供了movk这样的指令，这样的操作也很容易被实现**）*

*这种分割出16bits的切片以保存立即数的方法适合movk，movz，movn；其他的指令，例如b，bl，adrp，adr等等，则另有其他的重定位类型*

...

*G0重定位，被用于加载低16bits[15:0]的值，除非被明确的禁止，否则应当检查被加载的值是否<=2^16；G1应当检查是否小于2^32，G2应当检查是否小于2^48，G3就不用检查了（**李富贵注：这里的检查，指的是检查完成操作后，寄存器的值；例如：G0检查，检查的是将一个数送入寄存器的低16bits后，寄存器中的值 是否大于2^16?   G1检查，检查的是将16bits的数据送入寄存器[31:16]后，寄存器中的数是否大于2^32 **）*

*运算符：*

*为了书面的美观，重定位的名字中并没有包含R_AARCH64_ 前缀（以下提到的relocation name本身都应该加一个R_AARCH64_前缀）*

````tex
Operator    | Relocation name | Operation | Inst | Immediate | Check
------------+-----------------+-----------+------+-----------+----------
:abs_g0:    | MOVW_UABS_G0    | S + A     | movz | X[15:0]   | 0≤X≤2^16
------------+-----------------+-----------+------+-----------+----------
:abs_g0_nc: | MOVW_UABS_G0_NC | S + A     | movk | X[15:0]   | 
------------+-----------------+-----------+------+-----------+----------
:abs_g1:    | MOVW_UABS_G1    | S + A     | movz | X[31:16]  | 0≤X≤2^32
------------+-----------------+-----------+------+-----------+----------
:abs_g1_nc: | MOVW_UABS_G1_NC | S + A     | movk | X[31:16]  | 
------------+-----------------+-----------+------+-----------+----------
:abs_g2:    | MOVW_UABS_G2    | S + A     | movz | X[47:32]  | 0≤X≤2^48
------------+-----------------+-----------+------+-----------+----------
:abs_g2_nc: | MOVW_UABS_G2_NC | S + A     | movk | X[47:32]  | 
------------+-----------------+-----------+------+-----------+----------
:abs_g3:    | MOVW_UABS_G3    | S + A     | movk | X[64:48]  | 
            |                 |           | movz |           |
------------+-----------------+-----------+------+-----------+----------
:abs_g0_s:  | MOVW_SABS_G0    | S + A     | movz | X[15:0]   | |X|≤2^16
            |                 |           | movn |           |
------------+-----------------+-----------+------+-----------+----------
:abs_g1_s:  | MOVW_SABS_G1    | S + A     | movz | X[31:16]  | |X|≤2^32
            |                 |           | movn |           |
------------+-----------------+-----------+------+-----------+----------
:abs_g2_s:  | MOVW_SABS_G2    | S + A     | movz | X[47:32]  | |X|≤2^48
            |                 |           | movn |           |
------------+-----------------+-----------+------+-----------+----------
````

*这种重定位的典型用法*

```assembly
Unsigned 64 bits                     
movz    x1,#:abs_g3:u64               
movk    x1,#:abs_g2_nc:u64            
movk    x1,#:abs_g1_nc:u64            
movk    x1,#:abs_g0_nc:u64
@ 李富贵注:
@ 1.首先将一个16bit的数使用movz移动到x1中，由于movz的特性，这个操作会同时将[63:48]之外的内容全部清空
@ 2. 后续的3个movk操作，将操作数移入x1中即可（这里一定要复习以下movk和movz，不了解这两个指令是无法理解这个过程的）

Signed 64 bits
movz  x1,#:abs_g3_s:u64
movk  x1,#:abs_g2_nc:u64
movk  x1,#:abs_g1_nc:u64
movk  x1,#:abs_g0_nc:u64
```

*group relocation也可以用如下的操作符*

```tex
Operator    | Relocation name | Operation | Inst | Immediate | Check
------------+-----------------+-----------+------+-----------+----------
[implicit]  | LD_PREL_LO19    | S + A - P | ldr  | X[20:2]   | |X|≤2^20
------------+-----------------+-----------+------+-----------+----------
[implicit]  | LD_PREL_LO21    | S + A - P | adr  | X[20:0]   | |X|≤2^20
------------+-----------------+-----------+------+-----------+----------
[implicit]  | LD_PREL_LO21    | S + A - P | adr  | X[20:0]   | |X|≤2^20
------------+-----------------+-----------+------+-----------+----------
:pg_hi21:   | ADR_PREL_PG     | Page(S+A) | adrp | X[31:12]  | |X|≤2^32
            | _HI21           | - Page(P) |      |           |
------------+-----------------+-----------+------+-----------+----------
:pg_hi21_nc:| ADR_PREL_PG     | Page(S+A) | adrp | X[31:12]  | 
            | _HI21_NC        | - Page(P) |      |           |
------------+-----------------+-----------+------+-----------+----------
:lo12:      | ADD_ABS_LO12_NC | S + A     | add  | X[11:0]   | 
------------+-----------------+-----------+------+-----------+----------
:lo12:      | LDST8_ABS_LO12  | S + A     | ld   | X[11:0]   | 
            | _NC             |           | st   |           |
------------+-----------------+-----------+------+-----------+----------
:lo12:      | LDST16_ABS_LO12 | S + A     | ld   | X[11:1]   | 
            | _NC             |           | st   |           |
------------+-----------------+-----------+------+-----------+----------
:lo12:      | LDST32_ABS_LO12 | S + A     | ld   | X[11:2]   | 
            | _NC             |           | st   |           |
------------+-----------------+-----------+------+-----------+----------
:lo12:      | LDST64_ABS_LO12 | S + A     | prfm | X[11:3]   | 
            | _NC             |           |      |           |
------------+-----------------+-----------+------+-----------+----------
:lo12:      | LDST128_ABS     | S + A     | ?    | X[11:4]   | 
            | _LO12_NC        |           |      |           |
```



###### 解决方案2

抑或是向上面的例子一样，使用adrp指令，以page+offset的方式，将寻址范围扩大；

查阅adrp的指令说明（https://developer.arm.com/documentation/ddi0596/2021-12/Base-Instructions/ADRP--Form-PC-relative-address-to-4KB-page-?lang=en），可以清晰的看到adrp指令可以容纳21bits的立即数，并且adrp会以PC所在的Page为基准，将21bits的立即数左移12bits，扩展为33bits的带符号立即数，因此，adrp能够将寻址范围扩展到PC±4GB的范围；

这个方法虽然在过程中使用了PC，但只是寻址范围与PC有关，而获得结果还是一个绝对地址（可用于MOV之类的指令）；







