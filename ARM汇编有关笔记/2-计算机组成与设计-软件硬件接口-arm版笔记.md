# 计算机组成与设计-软件/硬件接口 ARM版本 笔记



## 序：

这是一篇读书笔记



## 并行编程

> 书在P43中举了一个例子：假设现在有一个新闻事件需要记者去报道，本着人多力量大的原则，或许可以让8个人一起撰写新闻稿；总的来说8个人写一篇稿子的效率是有可能能达到1个人的8倍的，但是很明显，真的要达到8倍并不容易，需要做很完美的安排8个人才有可能达到这个目标；为了提升协作效率，我们应当考虑以下几个事情：
>
> 1. 首先需要进行任务的规划，将撰写任务划分成可以被一同执行的部分
> 2. 要做好负载均衡，保证每个人的任务量基本相当，避免有人不做事，有人事多到做不完
> 3. 任务A可能依赖于其他人的任务B，只有其他人做完了对应的任务B之后，这个任务A才能开始；这时需要引入 `同步` 的概念；降低同步的资源消耗对于提升协作效率也是至关重要的；

上面这个例子很形象的说明了并行编程所面临的问题，该书使用5部分对上述问题进行了初步的说明；

这五个部分分别位于书中的：

ch2：并行 与 指令：同步（多核处理器如何同步工作？）

ch3：并行 与 计算机数学：结合律（并行计算是否满足结合律？计算的先后发生是否影响计算的结果？）

ch4：并行 与 高级指令集并行（介绍一些激进的并行技术，例如同时获取和执行多条指令；猜测决策的结果；推测性的执行指令等）

ch5：并行 与 内存层次：缓存一致性

ch6：并行 与 I/O：廉价磁盘冗余阵列





### 2.11 并行（parallelism）与指令：同步

注：此处parallelism翻译为，并行（请注意并行与并发的区别）

如果任务（tasks）之间相互没有关联，那么平行运行他们是相对简单的；可不幸的是任务之间经常会发生合作；合作意味着某些任务正在写寄存器的时候，另一些任务就可能会需要读正在被写的这个寄存器；为了知晓任务何时完成写寄存器操作以至于能让其他的任务进行安全的操作，我们需要进行同步；如果没有同步，就可能会发生**数据竞争**，一旦发生数据竞争，程序的结果可能会因为竞争发生的情况而改变；（大致可以理解为数据库中的脏读或者幻读）

如果某个任务需要读取另一个任务需要写的内容，那么就必须等待另一个任务将数据写入之后，才可以读取，这样就不用担心读取到错误的数据了；

在计算机中，`同步`机制由用户级的软件程序实现，这个软件程序有赖于**硬件支持的同步指令**，这个章节中，我们将重点关注**锁定（lock）**和**解锁（unlock）**同步指令的实现；我们可以直接使用lock和unlock创建 **只有一个处理器可以操作的区域** 我们称之为互斥操作（**mutual exclusion**），也可以使用lock和unlock实现其他的更为复杂的同步机制

在多处理器中实现同步，一组“有原子读写一个内存地址的能力”的硬件原语（hardware primitives）是至关重要的；也就是说当它进行一个读写操纵时候，没有任何其他的东西可以打断它的操作；如果没有原子读写硬件原语，那么同步原语的性能开支就很很大；

也有很多硬件原语可以替代他们，这些原语都提供了原子读写的能力，并且可以检查读写是否被原子执行；通常来说架构师并不希望用户直接使用这些硬件原语，架构师希望系统库调用这些原语，而暴露给用户的是系统库；

让我们来看看如何使用硬件原语取构建同步原语；一个典型的用于构建同步原语操作是 **原子交换（atomic exchange or atomic swap）**原子交换可以将寄存器中的一个值替换为内存中的一个值，ARM为这个操作提供了SWP指令；

看看如何使用SWP实现一个同步原语；假设我们想要构建一个简单的锁，用0表示锁是free状态，1表示锁是占用状态；一个处理器尝试使用SWP将某个寄存器中的值交换为1，而这个被操作的寄存器就是某个内存地址对应的锁；如果在这之前已经有其他的处理器宣布了对这个锁的占用，那么SWP将会返回1，否者返回0；在后一种情况下，寄存器中的值也会被同时设置为1，以防止其他的SWP也会拿到返回值0，从而产生竞争；

例如两个处理器同时尝试对某个内存地址上锁：此时这个竞争会被SWP打破，因为总有一个处理器先完成了交换，拿到了返回值0，而另一个处理器拿到了返回值1，表示它没有成功对这个内存上锁；使用交换原语（exchange primitive）实现同步锁的关键在于这个操作是原子的：即，交换是不可分割的，两个同时进行的交换将被硬件排序，因此两者不可能都拿到返回值0；

虽然SWP是针对多处理器同步而提出的，但是这个指令在单处理器多进程时也很有用

**这部分最重要的是：我们使用的同步指令，通常是有底层硬件支持的，就像SWP，我们不必担心多个SWP同时发生，即使真的同时发生，硬件也会将SWP进行排序，保证不会有冲突出现**
