# 计算机组成与设计-软件/硬件接口 ARM版本 笔记



## 序：

这是一篇读书笔记



## 并行编程（parallelism）

*请注意，并行和并发不是一个概念*

> 书在P43中举了一个例子：假设现在有一个新闻事件需要记者去报道，本着人多力量大的原则，或许可以让8个人一起撰写新闻稿；总的来说8个人写一篇稿子的效率是有可能能达到1个人的8倍的，但是很明显，真的要达到8倍并不容易，需要做很完美的安排8个人才有可能达到这个目标；为了提升协作效率，我们应当考虑以下几个事情：
>
> 1. 首先需要进行任务的规划，将撰写任务划分成可以被一同执行的部分
> 2. 要做好负载均衡，保证每个人的任务量基本相当，避免有人不做事，有人事多到做不完
> 3. 任务A可能依赖于其他人的任务B，只有其他人做完了对应的任务B之后，这个任务A才能开始；这时需要引入 `同步` 的概念；降低同步的资源消耗对于提升协作效率也是至关重要的；

上面这个例子很形象的说明了并行编程所面临的问题，该书使用5部分对上述问题进行了初步的说明；

这五个部分分别位于书中的：

ch2：并行 与 指令：同步（多核处理器如何同步工作？）

ch3：并行 与 计算机数学：结合律（并行计算是否满足结合律？计算的先后发生是否影响计算的结果？）

ch4：并行 与 高级指令集并行（介绍一些激进的并行技术，例如同时获取和执行多条指令；猜测决策的结果；推测性的执行指令等）

ch5：并行 与 内存层次：缓存一致性

ch6：并行 与 I/O：廉价磁盘冗余阵列





### 2.11 并行 与 指令：同步

注：此处parallelism翻译为，并行（请注意并行与并发的区别）

如果任务（tasks）之间相互没有关联，那么平行运行他们是相对简单的；可不幸的是任务之间经常会发生合作；合作意味着某些任务正在写寄存器的时候，另一些任务就可能会需要读正在被写的这个寄存器；为了知晓任务何时完成写寄存器操作以至于能让其他的任务进行安全的操作，我们需要进行同步；如果没有同步，就可能会发生**数据竞争**，一旦发生数据竞争，程序的结果可能会因为竞争发生的情况而改变；（大致可以理解为数据库中的脏读或者幻读）

如果某个任务需要读取另一个任务需要写的内容，那么就必须等待另一个任务将数据写入之后，才可以读取，这样就不用担心读取到错误的数据了；

在计算机中，`同步`机制由用户级的软件程序实现，这个用户级的软件程序是依赖于**硬件支持的同步指令**的，这个章节中，我们将重点关注**锁定（lock）**和**解锁（unlock）**同步指令的实现；我们可以直接使用lock和unlock创建 **只有一个处理器可以操作的区域** 我们称之为**互斥操作（mutual exclusion）**，也可以使用lock和unlock实现其他的更为复杂的同步机制

在多处理器中实现同步，一组“有原子读写一个内存地址的能力”的**硬件原语（hardware primitives）**是至关重要的；也就是说当它进行一个读写操纵时候，没有任何其他的东西可以打断它的操作；如果没有原子读写硬件原语，那么同步原语的性能开支就很很大；

也有很多硬件原语可以替代他们，这些原语都提供了原子读写的能力，并且可以检查读写是否被原子执行；通常来说架构师并不希望用户直接使用这些硬件原语，架构师希望系统库调用这些原语，而暴露给用户的是系统库；

让我们来看看如何使用硬件原语取构建同步原语；一个典型的用于构建同步原语操作是 **原子交换（atomic exchange or atomic swap）**原子交换可以将寄存器中的一个值替换为内存中的一个值，ARM为这个操作提供了SWP指令；

看看如何使用SWP实现一个同步原语；假设我们想要构建一个简单的锁，用0表示锁是free状态，1表示锁是占用状态；一个处理器尝试使用SWP将某个寄存器中的值交换为1，而这个被操作的寄存器就是某个内存地址对应的锁；如果在这之前已经有其他的处理器宣布了对这个锁的占用，那么SWP将会返回1，否者返回0；在后一种情况下，寄存器中的值也会被同时设置为1，以防止其他的SWP也会拿到返回值0，从而产生竞争；

例如两个处理器同时尝试对某个内存地址上锁：此时这个竞争会被SWP打破，因为总有一个处理器先完成了交换，拿到了返回值0，而另一个处理器拿到了返回值1，表示它没有成功对这个内存上锁；使用交换原语（exchange primitive）实现同步锁的关键在于这个操作是原子的：即，交换是不可分割的，两个同时进行的交换将被硬件排序，因此两者不可能都拿到返回值0；

虽然SWP是针对多处理器同步而提出的，但是这个指令在单处理器多进程时也很有用

*个人总结：我们使用的同步指令，通常是有底层硬件支持的，就像SWP，我们不必担心多个SWP会发生冲突，即使SWP时同时发生的，硬件也会将SWP进行排序，保证不会有冲突出现；总之设计CPU的设计师不希望用户直接去调用硬件原语，我们用户平时调用的都是封装好的，但是我们无需担心底层实现，底层一定是互斥的*

### 3.6并行 与 计算机数学：结合律

一般情况下，程序的第一个版本通常是顺序（sequentially）运行的，之后再被重写为并行运行的；所以一个自然而然的问题是“这两个 版本运行的结果是一样的嘛？”如果不是，你就假定并行版本是有bug的，需要追踪；

这种方法假定当程序从顺序编程转为并发编程之后计算机计算结果不会受到影响，也就是说如果你需要将一百万个数字加起来，使用一个处理器顺序计算和使用一千个处理器并行计算，结果是一样的；这个假定也适用于2的整数补码；甚至出现溢出，这个假设也是适用的；我们也称这个假设为“结合律”

同样的，因为浮点数本身是实数的近似值，而且计算机的近似精度是有限的；因此浮点数的加法是不符合结合律的；

关于结合律，一个更加令人恼火的陷阱发生在并行计算机上，操作系统的调度器可能会根据当前正在运行的其他的程序的数量而使用不同数量的处理器去处理并行进程；没有意识到这一点的程序员可能会因为完全相同的输入和完全相同的程序但是每次运行得到的结果却不相同而感到困惑，因为每次运行处理器数量的变化都会造成浮点数计算的和有差异；

面对这个问题，当我们编写关于浮点数的并行程序时，应当验证结果是否可信，即使并行版本的结果和顺序版本的运行结果一致；这称之为数值分析（这是一个很学术的问题...对于我们搞嵌入式的人可能不必关注它，但是浮点数对数据库有很大的影响）

### 4.10并行 与 高级指令级并行

note：这部分只是对迷人的高级指令并行的简单介绍，如果你真的想要了解这部分内容，应当去看一些更专业的书；例如《computer architecture: A quantitative approach》第四版；接下来的内容在这本书里会被扩充成200页的内容...

流水线操作（pipelining）利用了指令中潜在的并行性；这种并行性被称为 指令级并行（instruction-level parallelism）；有两种方法提升潜在的指令级并行度；第一种是提升流水线的深度，以重叠（overlap）多的指令；以洗衣店洗衣（*note：这里的原文是laundry，这个单词的含义是包含：收集脏衣服，清洗，甩干，整理折叠等步骤*）举例子，如果洗(wash)这个步骤消耗的时间远远大于其他步骤所消耗的时间，那么我们可以将洗衣机分成三批，分别处理传统洗衣机一次性就要完成的三种任务：清洗，冲洗，甩干；这样一来我们就能把原本4个步骤的洗衣细化成六个步骤；同时，为了真正的达到全速(full-speed)，我们还需要重新平衡每个步骤的时间，无论是对于洗衣服还是对于计算机处理器都是这样；这样就可以提高潜在的并行性，因为每一步的执行周期更短，同等的时间周期内就可以折叠更多的指令；

另一个方法是复制电脑的内部组件（internal component），这样电脑在每个流水线阶段（pipeline stage）中就可以执行更多的指令；这种方法被称为多次发行（multiple issue）技术；举个例子：多次发行技术就好似往洗衣房内购置原先3倍的洗衣机，当然，同时也要招聘原先3倍的员工以保证在相同的时间内可以处理原先3倍的衣服；这种方法的缺点在于需要额外的工作量以保持所有的机器都处于忙碌状态，并且这种方法会把高负载转移到下一个流水线阶段（即：下一个流水线阶段也必须要承受高负载）；
