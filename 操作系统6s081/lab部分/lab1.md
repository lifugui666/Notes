

# lab1 system calls

不同于上一个lab，我们可以直接调用xv6提供的直接可用的system call；这个lab需要让我们自己实现一个system call



## System call tracing

 ```shell
 ## 最终实现的内容的结果应该如下：
 $ trace 32 grep hello README
 3: syscall read -> 1023
 3: syscall read -> 966
 3: syscall read -> 70
 3: syscall read -> 0
 
 ## 32是 1<<SYS_read; SYS_read的数值可以在kernel/syscall.h中找到
 ```

实现过程

step0：需要在`user/user.h`中添加一个`trace()`

```c
//user/user.h
int trace(int);
```



step1： 需要在`user\usys.pl`中添加一个entry

```perl
#!/usr/bin/perl -w

# Generate usys.S, the stubs for syscalls.

print "# generated by usys.pl - do not edit\n";

print "#include \"kernel/syscall.h\"\n";

sub entry {
    my $name = shift;
    print ".global $name\n";
    print "${name}:\n";
    print " li a7, SYS_${name}\n";
    print " ecall\n";
    print " ret\n";
}

entry("fork");
#...
entry("trace"); # 添加这个trace entry
```

step2： 在syscall.c和syscall.h中添加sys_trace

```c
// syscall.h中

#define SYS_fork 1;
//...
#define SYS_trace 22;

// syscall.c中
extern uint64 sys_chdir(void);
//....
extern uint64 sys_trace(void);

static uint64 (*syscalls[])(void) = {
[SYS_fork]    sys_fork,
//...
[SYS_trace]   sys_trace,
};
// 这是一个名为syscalls的数组，数组中的内容是指针，指针是指向uint64 (void)的函数的；
```

step3： 实现trace

```c
// kernel/proc.h
//...
struct proc
{
    //...
    int mask;
    //...
}
```

















































