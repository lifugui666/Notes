

# lab1 system calls

不同于上一个lab，我们可以直接调用xv6提供的直接可用的system call；这个lab需要让我们自己实现一个system call



## System call tracing

 ```shell
 ## 最终实现的内容的结果应该如下：
 $ trace 32 grep hello README
 3: syscall read -> 1023
 3: syscall read -> 966
 3: syscall read -> 70
 3: syscall read -> 0
 
 ## 32是 1<<SYS_read; SYS_read的数值可以在kernel/syscall.h中找到
 ```



### hint

Some hints:

- Add `$U/_trace` to UPROGS in Makefile
- Run make qemu and you will see that the compiler cannot compile `user/trace.c`, because the user-space stubs for the system call don't exist yet: add a prototype for the system call to `user/user.h`, a stub to `user/usys.pl`, and a syscall number to `kernel/syscall.h`. The Makefile invokes the perl script `user/usys.pl`, which produces `user/usys.S`, the actual system call stubs, which use the RISC-V `ecall` instruction to transition to the kernel. Once you fix the compilation issues, run trace 32 grep hello README; it will fail because you haven't implemented the system call in the kernel yet.
- Add a `sys_trace()` function in `kernel/sysproc.c` that implements the new system call by remembering its argument in a new variable in the `proc` structure (see `kernel/proc.h`). The functions to retrieve system call arguments from user space are in `kernel/syscall.c`, and you can see examples of their use in `kernel/sysproc.c`.
- Modify `fork()` (see `kernel/proc.c`) to copy the trace mask from the parent to the child process.
- Modify the `syscall()` function in `kernel/syscall.c` to print the trace output. You will need to add an array of syscall names to index into.



### 实现过程

step0：需要在`user/user.h`中添加一个`trace()`

```c
//user/user.h
int trace(int);
```

step1： 需要在`user\usys.pl`中添加一个entry

```perl
#!/usr/bin/perl -w

# Generate usys.S, the stubs for syscalls.

print "# generated by usys.pl - do not edit\n";

print "#include \"kernel/syscall.h\"\n";

sub entry {
    my $name = shift;
    print ".global $name\n";
    print "${name}:\n";
    print " li a7, SYS_${name}\n";
    print " ecall\n";
    print " ret\n";
}

entry("fork");
#...
entry("trace"); # 添加这个trace entry
```

step2： 在syscall.c和syscall.h中添加sys_trace

```c
// syscall.h中

#define SYS_fork 1;
//...
#define SYS_trace 22;
```

```c
// syscall.c中
extern uint64 sys_chdir(void);
//....
extern uint64 sys_trace(void);

static uint64 (*syscalls[])(void) = {
[SYS_fork]    sys_fork,
//...
[SYS_trace]   sys_trace,
};
// 这是一个名为syscalls的数组，数组中的内容是指针，指针是指向uint64 (void)的函数的；
//....
void
syscall(void)
{
  int num;
  struct proc *p = myproc();

  num = p->trapframe->a7;
  if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
    p->trapframe->a0 = syscalls[num]();
    //--------------------- 添加如下 ------------------
    // 判断mask是不是命中了本次syscall，如果命中了本次syscall，就输出一下信息
    if( (1 << num) & p->mask )
    {
            printf(
                            "%d:syscall %s -> %d\n",
                            p->pid,
                            syscalls_name[num],
                            p->trapframe->a0
                            );
    }
    //-------------------------------------------------
  } else {
    printf("%d %s: unknown sys call %d\n",
            p->pid, p->name, num);
    p->trapframe->a0 = -1;
  }
}
```



step3： 实现trace

```c
// kernel/proc.h
//...
// Per-process state
struct proc {
  int mask;//添加一个mask，用于记录trace的目标
  struct spinlock lock;

  // p->lock must be held when using these:
  enum procstate state;        // Process state
  struct proc *parent;         // Parent process
  void *chan;                  // If non-zero, sleeping on chan
  int killed;                  // If non-zero, have been killed
  int xstate;                  // Exit status to be returned to parent's wait
  int pid;                     // Process ID

  // these are private to the process, so p->lock need not be held.
  uint64 kstack;               // Virtual address of kernel stack
  uint64 sz;                   // Size of process memory (bytes)
  pagetable_t pagetable;       // User page table
  struct trapframe *trapframe; // data page for trampoline.S
  struct context context;      // swtch() here to run process
  struct file *ofile[NOFILE];  // Open files
  struct inode *cwd;           // Current directory
  char name[16];               // Process name (debugging)
};
```

在`kernel/proc.c`的fork()函数中添加对mask的处理

```c
int
fork(void)
{
  //...
    
  np->mask = p->mask;// 将父进程的mask也一并赋值给子进程

  //...
}
```

### 分析

trace这个功能，主要依赖于`syscall`函数，系统调用的整体过程:

ecall->syscall->真正的系统调用处理函数；

其中syscall负责将请求发给真正的处理函数，所以syscall可以被认为是是一个"system call hub"...

所以我们可以在syscall中设立一个过滤条件







## sysinfo

这个lab要求我们输出：

1. 空闲的内存
2. 进程数量



### 实现过程

1. 在makefile里添加`%U/_sysinfotest`

2. 在user/user.h种添加sysinfo的用户接口

   ```c
   // user/user.h
   struct stat;
   struct rtcdate;
   struct sysinfo;
   
   // system calls
   int fork(void);
   //....
   int sysinfor(struct sysinfo *);
   ```

   note：C语言允许 结构体 先声明，再定义；`struct sysinfo`并不在`user.h`中声明，它在`kernel/sysinfo.h`中；

   

3. 在`usys.pl`中添加`sysinfo`的入口

   ```perl
   ##.............
   entry("sysinfo");
   ```

4. 在`kernel/syscall.h`中添加SYS_sysinfo的系统调用编号

   ```c
   #define SYS_sysinfo 23
   ```

5. 在`kernel/syscall.c`中的`syscalls数组`中添加`sysinfo函数`，以及真正的系统调用函数`sys_sysinfo`的声明；

   ```c
   extern uint64 sys_sysinfo(void); // 先声明，真正的实现不在里
   
   static uint64 (*syscalls[])(void) = {
   //.....
   [SYS_sysinfo] sys_sysinfo,
   };
   ```

6. 在`kernel/sysproc.c`中添加函数的实现

   ```c
   uint64 sys_sysinfo(void)
   {
           return 0;
   }
   ```



7. 接下来的工作需要获得**空闲的内存大小**和**当前处于UNUSED状态的进程数量**

   1. 在`kernel/kalloc.c`中，添加一个能够获取当前内存空间的函数

      ```c
      uint64 kfreemem(void)
      {
              struct run *r;
              uint64 count = 0;
              acquire(&kmem.lock);
      
              r = kmem.freelist;
              while(r)
              {
                      r = r -> next;
                     count ++;
              }
              release(&kmem.lock);
              return count * PGSIZE;
      }
      ```

   2. 在`kernel\sysproc.c`中，添加一个能够获取当前所有进程数量的函数

      ```c
      uint64 proc_num(void)
      {
              struct proc *p;
              uint64 count = 0;
              for(p = proc; p < &proc[NPROC]; p++)
              {
                      acquire(&p->lock);
                      if(p->state != UNUSED)
                      {
                              count ++;
                      }
                      release(&p->lock);
              }
              return count;
      }
      ```

   3. 在`kernel/defs.h`中添加`proc_num`和`kfreemem`的声明

      ```c
      // proc.c
      int             cpuid(void);
      //....
      uint64          proc_num(void);// 新增
      
      // ...
      
      // kalloc.c
      void*           kalloc(void);
      void            kfree(void *);
      void            kinit(void);
      uint64          kfreemem(void);// 新增
      ```

   4. 在`kernel/sysproc.c`中将`sys_info`函数完善

      ```c
      uint64 sys_sysinfo(void)
      {
              uint64 info;
              struct sysinfo kinfo;
              struct proc *p = myproc();
              if(argaddr(0, &info) < 0)
                      return -1;
              kinfo.freemem = kfreemem();
              kinfo.nproc = proc_num();
              if( copyout(p->pagetable, info, (char*)&kinfo, sizeof(kinfo))<0 )
                      return -1;
              return 0;
      }
      ```

      









































