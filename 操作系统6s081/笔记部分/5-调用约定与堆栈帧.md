# calling convention and stack frame

6s081文档：



https://pdos.csail.mit.edu/6.828/2020/tools.html

## risc-v的寄存器约定

![image-20240310143906242](.\图片\riscv-register.png)

上图是riscv寄存器的描述，你可以在6s081的官网的references->risc-v->calling convention中找到这个表格；

这里需要解释以下第四列

我们称调用着为caller，被调用者为callee；

`caller register`-> 该寄存器的内容由caller负责保存。无论callee怎么修改，一旦返回caller，值就会复原 

`callee register`-> 该寄存器的内容由callee负责保存。 站在caller的角度看，callee register的值在调用callee前后是一致的；

`ra`是一个**caller register**，这意味着无论callee函数怎么修改ra，一旦返回caller，这个寄存器的值都会被复原；

**需要注意的是，寄存器值的复原，本质上是需要代码实现的，通过查看汇编代码会发现，ra的复原实际上是caller中的汇编代码实现的；尽管这些工作由编译器完成，但是还是要知道这个过程**



总的来说，每一个rsicv register是一个64bits的存储器，可以用来传递参数，返回结果，register是我们能使用的最快速的存储/读取方式；一般来说只要寄存器放得下，我们都会选择使用寄存器，如果需要传递的参数太大了，寄存器放不下，那么我们就会选择在寄存器中放一个地址，指向内存，使用内存传递参数或者结果；

## stack frame



![image-20240310151808233](.\图片\stack-frame.png)



每次调用函数的时候，函数都会给自己创建一个stack frame

stack frame有以下的性质：

1. **stack frame是从高地址向低地址增长的**
2. stack frame中包含了寄存器，局部变量（所以你现在知道了为什么局部变量出了函数就失效了）
3. return address总是stack frame的第一位
4. 指向前一个stack frame的指针也会出现在stack frame中固定的位置上

每一个stack frame都有两个重要的指针：

1. `fp` frame pointer 指向stack frame 的顶端
2. `sp` stack pointer 指向stack frame 的底端

函数会通过移动sp来完成stack frame的创建；



question：stack frame中包含了上一级stack frame的指针，那么，这个“上一级”指的是位置处于该stack frame上面的frame，还是上一级函数（也就是调用当前函数的函数）的frame？

answer：其实这两个是一个东西...stack frame是被调用的时候才会被创建的，所以，如果A调用B，那么A的stack frame一定处于B的stack frame的上面，两者必定相邻；



## stack frame的创建

stack frame是需要使用汇编代码进行创建的；这部分工作是由编译器完成的，所以如果你不看汇编代码的话基本上永远不会发现stack frame的创建过程；

通常的函数都会是以下结构：

```assembly
# function prologue

# body

# Epllogue
```

举个例子：

```assembly
sum_to:
	mv t0, a0
	li a0, 0
	loop:
	add a0, a0, t0
	addi t0, t0, -1
	bnez t0 loop
	ret

.global sum_then_double
sum_then_double:
	# prologue 这两行用于创建一个stack frame
	addi sp, sp, -16; 	# 将sp-16，就会扩展出一个长度为16字节的frame
	sd ra, 0(sp)	 	# ra中的值保存到sp+0中
	#body
	call sum_to # sum_to是一个函数
	li t0, 2
	mul a0, a0, t0
	# Epllogue
	ld ra, 0(sp)	# 重新将sum_then_double自己的返回地址（存放于）填入ra寄存器
	addi sp, sp, 16 # sp+16，销毁一个frame
	ret
```

在本例中：sum_then_dobule函数创建了stack frame，但是sum_to函数并没有为自己创建stack frame；

先来看sum_then_double的操作：

1. 当进入`sum_then_double`函数的时候，`ra`寄存器就已经被覆写为`sum_then_dobule`的返回地址；
2. `sum_then_double`函数一上来就创建了属于自己的`stack frame`，它通过将sp=sp-16操作，为自己开辟了一段长度为16 bytes的空间；
3. 然后`sum_then_double`将自己的`ra`保存了下来，保存在sp+0这个地方；
4. 调用`sum_to`，`ra`寄存器此时会被`sum_to`覆写为自己的返回地址，也就是`sum_then_double`的地址，这里并不难理解，因为`sum_then_double`调用`sum_to`，那么`sum_to`返回的时候自然也就要返回`sum_then_dobule`
5. `sum_then_double`在调用完 `sum_to`之后，又将sp+0中的值重新赋给ra寄存器，这样就不会影响`sum_then_double`的返回；
6. `sum_then_double`销毁自己创建的`stack frame`；

可见，`stack frame`由函数自己创建，当然也可以选择不创建，`leaf function`是不创建`stack frame`的；





















































