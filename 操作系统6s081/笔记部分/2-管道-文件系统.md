# 2

## 前言



我看到的mit的6.s081没有第二集...但是在做lab的时候还是有一些知识点课程里没有讲解，应该就是第二季的内容了...这里我自学一下



## pipe

**pipe的本质是内核的一块内存，不同的进程之间可以使用这块内存交换数据**

pipe就是管道；在linux中，我们时常使用`ls |grep xxx `就是一个标准的管道，大致的含义是`ls`的输出，会被当做`grep`的输入

这是命令行级别的管道；实际上在unix中，我们在编写代码的时候也可以使用pipe

```c
//...
int p[2];
pipe(p);
//...
```

`pipe()`使用的一个长度为2的int数组为参数，在执行了`pipe(p)`之后，`p[0]`和`p[1]`会变成两个文件描述符;

**其中`p[0]`是pipe 的`read end`**， **`p[1]`是pipe的`write end`**

pipe最常见的应用场景是：有血缘关系的进程之间传递数据（比如，父进程给子进程传递数据）

对进程而言，pipe是两个文件描述符，一个可以用来读取，一个可以用来写，下面的代码是lab中的一个练习，我需要借助代码向你展示pipe；

```c
// 按照我的理解写一个pingpong
# include "kernel/types.h"
# include "kernel/stat.h"
# include "user/user.h"

int main()
{
    int p[2];
    char buffer[1];
    pipe(p);
    
    if ( fork() == 0 )	//子进程走if分支
    {
        close(p[1]);//关闭 write end
        read(p[0], buffer, 1);
        printf("%d: received ping\n",getpid());
    }
    else				//父进程走else分支
    {
        close(p[0]);//关闭 read end
        write(p[1], "x", 1);
        printf("%d: received pong\n", getpid());
    }
    
    exit(0);
}
```

上述代码中，我们使用`fork()`创建了一个子进程，但是fork的位置位于pipe()之后；这意味着，`child`和`parent`两者都持有`p[0]`和`p[1]`；但pipe是半双工的，也就是说`child`和`parent`都可以通过p[0]向pipe中写内容，也都可以通过p[1]从pipe中读内容；但是这两种过程不能同时发生；

这里我倾向于理解为：pipe被创建后，只有一份p[0]和p[1]，但是这一份管道却可以被多个进程引用；就像文件那样，我们当然可以在多个进程中打开同一个文件；

pipe有以下特性：

1. 使用`pipe(p)`创建的管道，p[0]是read end，p[1]是write end；
2. pipe是半双工工作的（即：pipe可以向两个方向传递数据，但是不能同时传输）
3. **如果没有任何进程引用pipe的write end，但是仍旧有进程尝试从pipe中read，那么read将会返回0，就像文件到达尾端一样；**
4. 如果pipe的write end有被引用，但是持有write end的进程却没有向pipe中写入数据，那么，当pipe中没有东西却还要调用read时，read会进入阻塞状态；
5. 如果一直向管道里写，管道满了还尝试调用write，那么会阻塞，直到pipe中有空闲可以被继续写入为止；



## 文件系统

关于文件系统，这里我翻译xv6book中的部分内容，如有错误请指正

有用于创建新的文件或者目录的system call：

mkdir用于创建新的目录；

使用O_CREATE参数的open函数可以创建文件；

mknod可以用于创建驱动文件；

下面的代码是例子

```c
mkdir("/dir");
fd = open("/dir/file", O_CREATE|O_WRONLY);
close(fd);
mknod("/console", 1, 1);
```

`Mknod`是一个特殊的文件，这个文件与设备相关；与设备文件相关的两个设备号（主设备号和次设备号，也就是Mknod的两个参数）能够唯一确定一个内核设备；当进程打开设备文件的时候，内核会将read和write调用转移到内核设备实现（kernel device implemention）而不是交给文件系统；

文件名称 和 文件本身 是不一样的两个概念，一个本质上的文件，称为inode，它可以有很多不同的名字，称为links；每一个link包含一个目录中的entry，这个entry包含着一个文件名称和一个inode的引用；一个inode则持有文件的metadata（元数据），包括文件的类型（文件？目录？设备？），文件的长度，文件在磁盘中的位置，文件的链接的数量；

`fstat` syscall可以从文件描述符引用的inode中检索信息：

```c
#define T_DIR 1 // Directory
#define T_FILE 2 // File
#define T_DEVICE 3 // Device
struct stat {
int dev; // File system’s disk device
uint ino; // Inode number
short type; // Type of file
short nlink; // Number of links to file
uint64 size; // Size of file in bytes
};
```

`link`syscall可以创建一个已经存在的inode的另一个名称；

```c
open("a", O_CREATE|O_WRONLY);
link("a", "b");
```

从`a`中读取文件，或者写文件，和从`b`中读，写文件没有什么区别；每一个inode都是由一个唯一的inode number表示的；当我们执行了上述的代码之后，我们可以通过`fstat`的结果来确定`a`和`b`指向同一个潜在的inode，两者都会返回同样的ino，并且nlink等于2；

`unlink`系统调用可以解除link，就不细说了....













