# 第四课 页表





## 页（page）机制

为了程序的隔离性，程序们都运行在虚拟内存中，每个程序都拥有独立的虚拟内存空间；但是归结到底，数据总是需要被放在物理内存里的，虚拟内存只不过是为了方便内存管理，在真实的物理内存和应用程序之间构建起来的一个映射关系罢了；



这里隐藏了一个问题，如果这个映射关系是一一映射，那么，但是这个映射表就会轻易的消耗全部的物理内存；64位机的寻址能力高达2^64，这意味着一个进程的虚拟内存最多可以有2^64Bytes 也就是2^34GB，也就是说如果按照这个虚拟内存一一映射物理内存，你的设备至少需要2^34GB才堪堪能容纳映射表；



这个问题的解决思路如下：

1. 不要给每个内存地址都创建一个表单条目，而是给每个`page` 创建一个表单条目，在risc-v里，一个`page`的大小是4kb（4096Bytes）;**请注意，一个page在物理内存中是连续的；**
2. 将虚拟内存划分为两个部分， index和offset，index用来索引page，offset用于在page内索引；



**页 page 就是，连续的4KB的物理内存，页也是操作系统进行内存管理的基本单位**



在risc-v中，**虚拟内存**并没有用掉64bits，只用掉了39bits，其中27个bits存储index，12个bits存储offset；

| EXT              | index  | offset |
| ---------------- | ------ | ------ |
| 25bits（无效的） | 27bits | 12bits |

`index`用于索引`page`，`offset`用于在`page`内索引

正如前文所说，一个`page`的大小是4KB，所以`offset`是12bits(2^12 = 4KB，覆盖了一个`page`的范围)



在risc-v的设计中，**物理内存**的`index`有56bits(但其中只有44bits是物理`page`号，称为PPN-physical page number)，**物理内存**的`offset`有12bits；



## 三级页表（page table）机制

**请注意：三级页表机制，是一个硬件机制，由MMU负责，但是OS偶尔也需要处理内存地址问题，因此其实OS也有实现三级页表机制的软件功能**

接下来关注`index`部分，`index`有27bits，换言之有2^27个`page`可用，如果对2^27都建立映射关系，一个`page`需要64bit以保存映射关系，2^27个page需要1GB，这不是一个小数目，如果每个应用程序都需要对2^27个`page`建立映射关系，还是要消耗很多的物理内存；

因此虚拟内存的`index`，又被分为三个部分L2，L1，L0；每部分9bits；如下图所示

![image-20240225185510808](.\图片\image-20240225185510808.png)

L2用来索引最高级的`page directory`，一个`directory`包含2^9=512个PTE（page table entry）条目，每个PTE条目64bits；（实际上这里的page directory就是一个页表 page table）

**SATP寄存器会指向最高一级的page directory，请务必注意，SATP中存的是一个物理内存地址；实际上page directory都必须被放在物理内存中；** 

最高级的`page directory`只有一个，`satp`寄存器会持有最高一级的`page directory`的索引，L2的9bits会指向这512个条目中的一个条目（PTE），这个PTE的前44bits会持有下一级`page directory`（**只需要在这44bits后补充12bits的0，就可以得到下一级page directory的起始地址**，这个地址也必须是真是的物理地址）；然后依次类推...直到最后一级，我们会得到虚拟地址对应的物理地址的PPN，再加上虚拟地址中的12bits `offset`，合成真实的物理地址；



so，如果仔细计算一下，如果要对2^27个页(`page`)进行编码：

1. 使用一级页表（page table）需要2^27个直接指向页的PTE（这里提到的的PTE和page directory无关）需要消耗 1GB内存；

2. 如果使用三级页表（page table）；第一级页表（page table）512个PTE，需要4KB，第二级页表（page table）512\*512个PTE，需要2MB，三级页表（page talbe）512\*512*512个PTE，需要1GB；？？？如果按照三级页表，甚至比直接对页表进行存储还多消耗了2.0039MB左右的内存。为什么说三级页表节省内存？



三级页表节省内存的重要原因在于：**三级页表机制允许页表离散储存**

页表（page table）的工作方式很像是数组，内核查询page table的方式是通过page table起始地址+偏移下标实现的；如果只有一级page table的话，为了防止随机访问带来的问题，我们需要将全部的页表用PTE映射起来；

即：

1. 如果使用一级页表，会导致即使我们的程序只用到一个页表，就需要把2^27个页表全部用PTE记录起来；

2. 如果使用三级页表，只用到一个页表的话，完全可以只是用三个PET去记录；用到谁再创建谁；因为大多数软件并不会真的用掉海量的内存，因此这种方式更为灵活，也就节省了更多的内存；

*这里的思想与  链表和数组  之间的关系很接近；*



关于page directory必须要注意的是：

**page directory的起始地址必须是在物理内存中的，换言之page directory不能放在虚拟内存中，因为三级页表在逐级递进的时候，使用的是PPN，物理页表号**



  从图中可以看出来，PET中除了有44个bit的PPN，还有10个bits的flags，其中前五个比较重要，介绍一下:

valid：表示该PET可用（一个page directory中，每个PET都可以独立设置该PET是否可用）

readable：这个页表是否可读

writeable：这个页表是否可写

executable：是否允许从这个page中执行命令

user：这个页表是否允许处在用户空间的进程访问；



## 页表缓存(TLB)机制

translation look-aside buffer；本质上是对PTE的缓存；

TLB机制会在完成一次虚拟地址-物理地址之间的翻译之后，将结果存起来；如果很快再次遇到这个地址，就不需要再次查询3级以获取物理地址；TLB会直接返回缓存结果；



TLB是处理器的硬件功能之一；因此对于OS而言，TLB的实现方式是黑盒；



我们需要知道TLB的原因是，当OS切换了page table的时候，需要明确的告知处理器：页表发生了更换，处理器会清空TLB，因为之前的TLB在页表发生变化后已经失效；





## kvminit函数初始化页表的流程



```c
// kernel/main.c

#include "types.h"
#include "param.h"
#include "memlayout.h"
#include "riscv.h"
#include "defs.h"

volatile static int started = 0;

// start() jumps here in supervisor mode on all CPUs.
void
main()
{
  if(cpuid() == 0){
    consoleinit();
    printfinit();
    printf("\n");
    printf("xv6 kernel is booting\n");
    printf("\n");
    kinit();         // physical page allocator
    kvminit();       // create kernel page table
    kvminithart();   // turn on paging
//.....
```



```c
// kernel/vm.c
#include "param.h"
#include "types.h"
#include "memlayout.h"
#include "elf.h"
#include "riscv.h"
#include "defs.h"
#include "fs.h"

//.....
pagetable_t kernel_pagetable;
//...
/*
 * create a direct-map page table for the kernel.
 */
void
kvminit()
{
  kernel_pagetable = (pagetable_t) kalloc();//给最高一级的 page directory分配物理page；但是此时MMU还没有开始工作，在被加载到SATP寄存器前，虚拟内存不会工作；
  memset(kernel_pagetable, 0, PGSIZE);// 将这段内存初始化为0

  // uart registers
  // 将uart设备映射到内核
  // 这里使用了PTE_R和PTE_W
  // UART0这个变量位于kernel/memlayout.h 是0x10000000L;
  // 在xv6中，低于0x8000000的地址会被用映射到一些IO设备上，高于0x80000000的地址才会被映射到RAM中
  // 值得一提的是，这些IO设备在虚拟内存中的地址和在物理内存中的地址是一样的，这样用起来就很方便
  kvmmap(UART0, UART0, PGSIZE, PTE_R | PTE_W);
  // 后面都是相似的东西 
  kvmmap(VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);
  kvmmap(CLINT, CLINT, 0x10000, PTE_R | PTE_W);
  kvmmap(PLIC, PLIC, 0x400000, PTE_R | PTE_W);
  kvmmap(KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);
  kvmmap((uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);
  kvmmap(TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);
}

// Switch h/w page table register to the kernel's page table,
// and enable paging.
void
kvminithart()
{
  // 这个函数设置了SATP寄存器
  // 这里是内核在告诉MMU，使用这个page table
  // 在这条指令之前，还不存在可用的page table
  //  ！！！这条指令是一条非常重要的指令，在这条指令之后，地址翻译就开始工作了
  w_satp(MAKE_SATP(kernel_pagetable));
  // 如果使用gdb，会发现好像在执行w_satp的前后，地址没有发生明显的变化，那是因为kernel page中，物理地址和虚拟地址是相等的；
  // 但你必须明确，在w_stap前，代码都在物理内存中；执行w_stap后，代码的地址是虚拟地址
  sfence_vma();
}

//.......

// add a mapping to the kernel page table.
// only used when booting.
// does not flush TLB or enable paging.
void
kvmmap(uint64 va, uint64 pa, uint64 sz, int perm)
{
  if(mappages(kernel_pagetable, va, sz, pa, perm) != 0)
    panic("kvmmap");
}

//.....
```











































