# 系统的结构和系统调用



没错，第一章下来就是第三章，中间没有第二章....我找到的课就是这样的....



## isolation 隔离性

所谓隔离性，就是要求软件和软件之间相互隔离，比如你的系统上同时运行着qq和微信，不能因为qq的崩溃而导致微信也跟着崩了；

如果qq和微信都直接运行在硬件上，那么他们之间就没有隔离，如此一来可能出现这样的问题：

qq先在0x11111111这个内存上放了一段话，但是微信并不知道，微信也在0x11111111这个地址的内存上放了一段话，那么此时，qq从0x11111111这个内存地址上再读出来的数据就不是它原先放进去的那段了；

当然实际情况可能更糟糕，被别的软件随意修改内存很大的概率会造成软件的崩溃；

我们的操作系统必须保证上述的情况不会发生，即，操作系统必须保证隔离性；

隔离性的核心是“多路复用 multiplexing” 与 “内存隔离”

实现这两个要求的途径是“抽象硬件资源”；

举个例子：

当我们使用fork的时候，会创建一个进程，虽然进程上跑的 应用程序 最终一定会交给CPU处理，但是进程本身又不是CPU；进程某种程度上就是对CPU的一种抽象；

类似的：

| 概念    | 对应的硬件功能 |
| ------- | -------------- |
| process | CPU            |
| exec    | 内存           |
| files   | 硬盘           |
| ...     | ...            |



在做系统相关的编程的时候，有一个概念叫做“防御性”； 你的代码应该具有防御性，不能因为应用软件的行为导致系统的崩溃；尽管来自软件的“攻击”可能是有意为之，也可能只是无心之举；

为了能够实现强隔离，我们需要硬件上的支持，如果你曾经学过微机原理，那么或许你对X86系列的处理器所提供的“实模式”，“保护模式”有一些认识，RISCV同样提供了类似的功能--“user\kernel mode”和“virtual mode”；实际上这种模式在几乎所有架构的CPU中都被广泛的使用...X86，arm，risc-v，都是这样运作的；



## 内核模式 kernel mode 与用户模式 user mode

### user/kernel mode

user mode: CPU只能执行unprivileged instruction（非特权指令）

kernel mode: cpu可以执行privileged instruction（特权指令）

所谓unprivileged instruction，例如：ADD，SUB，如果你有学过微机原理，那么你应该知道这两条指令的语义，这类操作属于任何一个软件都能使用的操作；

而privilege instruction，例如关闭时钟中断，设置page table寄存器等，这些操作是实打实的会对硬件产生作用的操作，因此不能让路边的阿猫阿狗随便去用；

**一般的处理器会通过一个flag来标志，当前CPU处于user mode还是kernel mode**



### 虚拟内存与页表

（虚拟内存有很多作用，主要的三个作用是 ：保证进程之间的内存隔，保证进程有连续内存可用 ，扩展物理内存；页表这个机制说白了就是建立虚拟内存与物理内存之间的关系）



虚拟内存存在的意义之一，就是为了让程序认为自己有连续可用的内存；因为物理内存会在被使用的过程中逐渐变成“碎片”

这里我需要解释一下什么是“碎片”：如果进程都运行在物理内存上，假设我们的物理内存只有4个bit，分别记作0x00，0x01，0x02，0x03；在刚开机的时候，这四个bit都是可用的，随后发生了如下的过程：

1. 进程A占用了前2个bit：0x00 0x01 
2. 进程B占用了第3个bit：0x02
3. 进程A结束，释放了前2个bit
4. 进程C开始申请内存，发现可用内存是0x00 0x01 0x03

内存碎片就此产生了，原本连续的四个bit，被分割开来了；

这就产生了一个问题，如果进程C想要连续的3bits物理内存，就无法实现了，尽管空闲内存的总量是有3bits的，但是这些内存不连续；不连续的内存会有使用问题，比如数组如果存在不连续的内存里就无法正常使用；

那么怎么解决这个问题？操作系统会维护一个叫做页表的东西，这个表的作用是将不连续的物理内存映射到连续的虚拟内存中，这样在软件眼里，软件就有连续的内存可用了；



每个进程都会有一个属于自己的“page table（页表）”，页表将虚拟内存映射在物理内存上，如此一来，进程只能访问出现在自己页表里的物理内存；

操作系统会设置页表，使得每一个进程都有不重合的物理内存；这样进程就不能访问其他进程在使用的物理内存；



## system call

如果你理解了user mode和kernel mode，会发现一个问题，如果user mode和kernel mode之间的隔离是完全隔离的话，那么普通的用户程序就无法切换到kernel mode执行必要的操作，这当然是不合理的；我们需要一个user mode和kernel mode之间的桥梁；

实际上risc-v提供了一个叫ECALL的指令，使用ECALL并且传入一个参数（2，3，4...），这里的参数代表程序想要调用的system call；

当前我们使用C语言调用fork()这个系统调用的时候，实际上本质还不是调用内核里叫做fork的那段代码，而是调用了ECALL，通过ECALL调用内核里的syscall函数，syscall函数会检查你的参数是否正确，如果正确，再由syscall去调用内核里的fork函数；



## XV6系统对上述三者的实现

对xv6而言（实际上对unix乃至linux系统而言都差不多..）

xv6操作系统本身是运行在kernel mode下的，整个操作系统内核都运行在kernel mode下，这种设计方式被称为宏内核设计，因为这个内核很大，包含了硬件驱动，文件系统等等一系列的子部分，宏内核设计能够获得较好的性能；但是一大坨代码堆在一起也更容易产生bug

还有另一种系统设计方式，被称为微内核，这种设计方式致力于减少运行在kernel mode中代码，内核中也会保留一些模块，但更多的模块只是作为一个普通的用户程序运行在 user mode下；windows采用的就是微内核设计；这种设计的bug率理论上会小一些；但是由于一部分子系统位于user mode下，完成同样的功能需要更多的user/kernel切换开销；



代码分析：

在代码分析之前，你必须了解一个系统是怎样被编译的；最好了解一下C语言的编译-连接过程；最好了解一下GCC和GDB的使用；

### xv6系统编译过程的介绍

当我们在/xv6-riscv这个目录下运行make命令的时候，就是在编译XV6；

然而操作系统本身也是一个软件，只是这个软件规模较大，比较特殊而已；

Unix类系统基本上可以被看做是一个使用大量C语言和少量其他别的语言所编写的软件，因此C语言程序需要的汇编连接等步骤，unix系统也不能免俗；如果你有用过GCC那么应该对上述的过程有一定的理解，如果你没用过，可以看看我写的C语言笔记或者ARM系列的笔记；

总的来说，在make之后，就会生成可执行文件，使用make qemu命令就可以用qemu去运行这个操作系统，qemu的作用是模拟一个riscv架构的CPU；





### xv6系统的结构介绍



```shell
# xv6的结构已经相当简单，主要内容有三个文件夹
lifugui@lifugui_thinkpa:/mnt/d/6s081/xv6-riscv$ ls
LICENSE  Makefile  README  fs.img  kernel  mkfs  user
# 其中重要的三个文件夹是 kernel mkfs user
# 1. kernel文件夹，包含了所有内核文件，这个文件夹里的全部可执行文件都会被运行在kernel mode下；
lifugui@lifugui_thinkpa:/mnt/d/6s081/xv6-riscv$ ls kernel/
bio.c      exec.c   fs.o         log.d        plic.d     sleeplock.c  stat.h     sysfile.d     uart.c
bio.d      exec.d   kalloc.c     log.o        plic.o     sleeplock.d  string.c   sysfile.o     uart.d
bio.o      exec.o   kalloc.d     main.c       printf.c   sleeplock.h  string.d   sysproc.c     uart.o
buf.h      fcntl.h  kalloc.o     main.d       printf.d   sleeplock.o  string.o   sysproc.d     virtio.h
console.c  file.c   kernel       main.o       printf.o   spinlock.c   swtch.S    sysproc.o     virtio_disk.c
console.d  file.d   kernel.asm   memlayout.h  proc.c     spinlock.d   swtch.o    trampoline.S  virtio_disk.d
console.o  file.h   kernel.ld    param.h      proc.d     spinlock.h   syscall.c  trampoline.o  virtio_disk.o
defs.h     file.o   kernel.sym   pipe.c       proc.h     spinlock.o   syscall.d  trap.c        vm.c
elf.h      fs.c     kernelvec.S  pipe.d       proc.o     start.c      syscall.h  trap.d        vm.d
entry.S    fs.d     kernelvec.o  pipe.o       ramdisk.c  start.d      syscall.o  trap.o        vm.o
entry.o    fs.h     log.c        plic.c       riscv.h    start.o      sysfile.c  types.h

# 2. user文件夹，包含了用户软件的代码，可以看到我们很熟悉的一些命令，像ls，grep等，都在这里
# （没错哦，这些命令其实每个都是一个单独的软件...原则上说这些命令并没有绑死在操作系统上...）
lifugui@lifugui_thinkpa:/mnt/d/6s081/xv6-riscv$ ls user
_cat        _zombie       grep.asm   initcode      ln.sym     rm.c          ulib.d         usys.pl
_echo       cat.asm       grep.c     initcode.S    ls.asm     rm.d          ulib.o         wc.asm
_forktest   cat.c         grep.d     initcode.asm  ls.c       rm.o          umalloc.c      wc.c
_grep       cat.d         grep.o     initcode.d    ls.d       rm.sym        umalloc.d      wc.d
_grind      cat.o         grep.sym   initcode.o    ls.o       sh.asm        umalloc.o      wc.o
_init       cat.sym       grind.asm  initcode.out  ls.sym     sh.c          user.h         wc.sym
_kill       echo.asm      grind.c    kill.asm      mkdir.asm  sh.d          user.ld        zombie.asm
_ln         echo.c        grind.d    kill.c        mkdir.c    sh.o          usertests.asm  zombie.c
_ls         echo.d        grind.o    kill.d        mkdir.d    sh.sym        usertests.c    zombie.d
_mkdir      echo.o        grind.sym  kill.o        mkdir.o    stressfs.asm  usertests.d    zombie.o
_rm         echo.sym      init.asm   kill.sym      mkdir.sym  stressfs.c    usertests.o    zombie.sym
_sh         forktest.asm  init.c     ln.asm        printf.c   stressfs.d    usertests.sym
_stressfs   forktest.c    init.d     ln.c          printf.d   stressfs.o    usys.S
_usertests  forktest.d    init.o     ln.d          printf.o   stressfs.sym  usys.d
_wc         forktest.o    init.sym   ln.o          rm.asm     ulib.c        usys.o

# 3. mkfs，提供了一个空的文件镜像，我们存在这个文件夹下的文件就可以在xv6中找到；
```





### 操作系统的启动

**在开始了解操作系统的启动流程前，必须明确，qemu的功能是模拟了一个硬件，qemu提供的功能和一个4核riscv核心的主板是一样的**

```shell
# 使用gdb启动qemu，这样qemu就以gdb模式启动了，相当于一个gdb server
lifugui@lifugui_thinkpa:/mnt/d/6s081/xv6-riscv$ make qemu-gdb
*** Now run 'gdb' in another window.
qemu-system-riscv64 -machine virt -bios none -kernel kernel/kernel -m 128M -smp 3 -nographic -global virtio-mmio.force-legacy=false -drive file=fs.img,if=none,format=raw,id=x0 -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0 -S -gdb tcp::26000

```

然后在相同路径下启动gdb，就可以调试这个xv6系统了

```shell
lifugui@lifugui_thinkpa:/mnt/d/6s081/xv6-riscv$ riscv64-unknown-elf-gdb
GNU gdb (GDB) 13.1
Copyright (C) 2023 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "--host=x86_64-pc-linux-gnu --target=riscv64-unknown-elf".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<https://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
    <http://www.gnu.org/software/gdb/documentation/>.

For help, type "help".
Type "apropos word" to search for commands related to "word".
The target architecture is set to "riscv:rv64".
warning: No executable has been specified and target does not support
determining executable automatically.  Try using the "file" command.
0x0000000000001000 in ?? ()
(gdb) 
# 后面会逐渐涉及到gdb的一些使用，等用到了再说
```



在编译xv6的时候，会产生一些asm文件，这些文件是软件的汇编语言版本，从这里开始我们就开始正式进入xv6的代码部分；

从/kernel/kernel.asm开始

```assembly
kernel/kernel:     file format elf64-littleriscv


Disassembly of section .text:

0000000080000000 <_entry>:
    80000000:   00009117                auipc   sp,0x9
    80000004:   a1010113                addi    sp,sp,-1520 # 80008a10 <stack0>
    80000008:   6505                    lui     a0,0x1
    8000000a:   f14025f3                csrr    a1,mhartid
    8000000e:   0585                    addi    a1,a1,1
    80000010:   02b50533                mul     a0,a0,a1
    80000014:   912a                    add     sp,sp,a0
    80000016:   078000ef                jal     ra,8000008e <start>

000000008000001a <spin>:
    8000001a:   a001                    j       8000001a <spin>
# 后面还有很多...暂时掠过，以这一小段作为样本简单解释一下asm文件怎么看
# 0000000080000000 <_entry>: 这里的_entry 是"段名"；段名类似于函数名，用户可以自己定义，但是要受到一些约束；总的来说段名是为了给人提供方便的，在后面的使用中详细你会逐渐体会到；
#	80000000:   00009117                auipc   sp,0x9
#	80000000是内存地址
#	00009117是机器码
#	auipc是指令（和汇编中的add，sub等等指令是一类东西）
#	sp，0x9是寄存器和操作数
#	这行代码合起来的意思是，在内存 80000000 里存着00009117，而00009117是一条指令，这条指令是auipc，参数是sp和0x9
```



使用gdb查看最开始的样子：

```assembly
0x0000000000001000 in ?? ()
(gdb) b _entry
# 注： b _entry表示在_entry处设置断点
Breakpoint 1 at 0x8000000a
(gdb) c
# c表示继续运行
Continuing.
[Switching to Thread 1.2]

Thread 2 hit Breakpoint 1, 0x000000008000000a in _entry ()
=> 0x000000008000000a <_entry+10>:      f14025f3                csrr    a1,mhartid
(gdb)
```

这里有一些需要解释的地方：

1. 为什么开始的地址是8000 0000而不是0000 0000？ 因为我们只看操作系统，实际上计算机启动的时候，最先运行的是一个引导程序，这个引导程序才是从0000 0000 开始运行的，负责做一些硬件上的初始化工作，对这个有兴趣的建议看看uboot；
2. 从8000 0000 开始就进入操作系统了吗？是的，从8000 0000 开始就已经正式进入操作系统了，不过在这里有很多东西都还没有被加载或者被初始化，还没有内存页，隔离性等东西
3. 此时这些代码运行在什么模式下？ 运行在M mode下， 这是riscv的机器模式，是riscv中权限最高的模式，xv6会尽快跳转到kernel mode的；































